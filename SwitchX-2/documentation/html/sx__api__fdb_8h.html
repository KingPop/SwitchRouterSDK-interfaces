<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SwitchX API: sx_api_fdb.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>sx_api_fdb.h File Reference</h1>
<p>
<a href="sx__api__fdb_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#184f700fe7eeb6f43055403da5a241f6">sx_api_fdb_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#5fed6dd8523c4e40d8e30df7dd5d8d20">sx_api_fdb_age_time_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#3e75bb5268ce8ee34fe58391dacf42f5">sx_api_fdb_age_time_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1ac12a3e87a1b4741de6e6b21b25a29">sx_api_fdb_poll_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#78a3fc73b9b74b08ab1c100b16b66eda">sx_api_fdb_polling_interval_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#b7e9578b266db285547b18dcff27a8ac">sx_api_fdb_uc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint16_t *data_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#cb0eeaab4331cd32326ea7a4d91303df">sx_api_fdb_uc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint16_t *data_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#94b95bb23afdb7c76d742d01204e663b">sx_api_fdb_uc_count_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, uint32_t *data_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#f5d254f251cfe5a95be3c62891df022c">sx_api_fdb_uc_port_count_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#332c511da70dea031ab33c65e0b996ec">sx_api_fdb_uc_fid_count_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#fff41b0a5d7311d86d929a03811ede6f">sx_api_fdb_uc_limit_port_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#83ac81748592a275cdaf12afadc33e74">sx_api_fdb_uc_limit_fid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_fid_t fid, const uint32_t limit)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#19055e813badb894992902ac11ef6ad4">sx_api_fdb_uc_limit_port_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#1d04bf658c8039ca8ed890aab54c6279">sx_api_fdb_uc_limit_fid_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fid_t fid, uint32_t *limit_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af5ddb361a67b1c01f642ef6b10e1348">sx_api_fdb_mc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint16_t port_cnt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#bc49a8d40d62974a94e4d8af60e3f637">sx_api_fdb_mc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint16_t *port_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0d6033f11a7b399dfb5a75213ae2fae">sx_api_fdb_mc_max_group_cnt_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *max_mc_group_cnt_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#887cf67a3d1f00041b3e41170992b4e8">sx_api_fdb_uc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#9908a902076cfa3e01aeea8c1abd4a4e">sx_api_fdb_uc_flush_port_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_port_log_id_t log_port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#e2c6745019a8e4699cb1cf4bc4feafe5">sx_api_fdb_uc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#e1eeef31bbde934d1d2ebfdef4c9b58a">sx_api_fdb_uc_flush_port_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_port_log_id_t log_port, const sx_fid_t fid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af812deb31ac080087cb525a41a195ec">sx_api_fdb_mc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#abc7188f337ed0e95235726c8ea37112">sx_api_fdb_mc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#7a6ce92e0d0b0673f0086b999e6ec139">sx_api_fdb_fid_vlan_member_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#fc0557c3946207da8e2d12b2578b33d3">sx_api_fdb_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#1a6037a85d5494d60ca656fb4e58679d">sx_api_fdb_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#1dfcf027836302463584baecffc3fff6">sx_api_fdb_learn_rate_limit_set</a> (const sx_api_handle_t handle, const sx_fdb_learn_limit_cmd_t learn_limit_cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t log_port, const uint16_t rate_limit)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#c510372668e0d39896fa326b32672765">sx_api_fdb_swid_global_learning_mode_set</a> (const sx_api_handle_t handle, const sx_swid_id_t swid_id, const sx_fdb_learn_ctrl_t learn_ctrl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ecf42acf4fbc24b07c606512574bbdec">sx_api_fdb_swid_global_learning_mode_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid_id, sx_fdb_learn_ctrl_t *learn_ctrl_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#9f4c2f9dd69de1a5ac743a6ccc81bd24">sx_api_fdb_fid_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#c5f2b448e2c230c0df877611b4b01e51">sx_api_fdb_fid_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#6d39c1c5a78a62b690dfbbf131dde373">sx_api_fdb_port_learn_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#348fa08614e9de19453041abb9521b05">sx_api_fdb_port_learn_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#82513c8c8099e62fbb226b62ce5521cd">sx_api_fdb_notify_params_set</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fdb_notify_params_t *notify_params_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sx_status_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#b5db2340bb3e3c83fc6ba52ca8167a45">sx_api_fdb_notify_params_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, sx_fdb_notify_params_t *notify_params_p)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="184f700fe7eeb6f43055403da5a241f6"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_log_verbosity_level_set" ref="184f700fe7eeb6f43055403da5a241f6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&nbsp;</td>
          <td class="paramname"> <em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&nbsp;</td>
          <td class="paramname"> <em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&nbsp;</td>
          <td class="paramname"> <em>api_verbosity_level_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the log verbosity level of FDB MODULE <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- SET / GET </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>verbosity_target</em>&nbsp;</td><td>- set get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>module_verbosity_level_p</em>&nbsp;</td><td>- FDB module verbosity level </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>api_verbosity_level_p</em>&nbsp;</td><td>- FDB API verbosity level</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS - Operation completes successfully <p>
SX_STATUS_CMD_UNSUPPORTED - Unsupported access command <p>
SX_STATUS_INVALID_HANDLE - NULL handle received <p>
SX_STATUS_COMM_ERROR - Client communication channel open failed <p>
SX_STATUS_PARAM_ERROR - Unsupported verbosity_target </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fed6dd8523c4e40d8e30df7dd5d8d20"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_age_time_set" ref="5fed6dd8523c4e40d8e30df7dd5d8d20" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_age_time_t&nbsp;</td>
          <td class="paramname"> <em>age_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the FDB age time, in seconds. Age time is the time after which auto learned addresses are deleted from the FDB if they receive no traffic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- Switch ID. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>age_time</em>&nbsp;</td><td>- Time in seconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e75bb5268ce8ee34fe58391dacf42f5"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_age_time_get" ref="3e75bb5268ce8ee34fe58391dacf42f5" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_age_time_t *&nbsp;</td>
          <td class="paramname"> <em>age_time_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets the FDB age time, in seconds. Age time is the time after which auto learned addresses are deleted from the FDB if they receive no traffic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- Switch ID. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>age_time_p</em>&nbsp;</td><td>- Time in seconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1ac12a3e87a1b4741de6e6b21b25a29"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_poll_set" ref="a1ac12a3e87a1b4741de6e6b21b25a29" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_poll_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function set the FDB poll for mac entries notifications<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_NO_RESOURCES if there is no place in jobs buffer. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78a3fc73b9b74b08ab1c100b16b66eda"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_polling_interval_set" ref="78a3fc73b9b74b08ab1c100b16b66eda" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_polling_interval_t&nbsp;</td>
          <td class="paramname"> <em>interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the FDB polling interval from HW in 0.1 seconds. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7e9578b266db285547b18dcff27a8ac"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_mac_addr_set" ref="b7e9578b266db285547b18dcff27a8ac" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint16_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&nbsp;</td>
          <td class="paramname"> <em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>data_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function adds/deletes UC MAC and UC LAG MAC entries to/from the FDB. In case the operation failed on one entry (or more), an error will be returned, mac_list will store those entries, and their quantity will be stored in data_cnt. If the operation finished successfully: SUCCESS will be returned, and data_cnt and mac_list won't be changed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- ADD/DELETE </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mac_list</em>&nbsp;</td><td>- list of mac record parameters. On deletion, entry_type is DONT_CARE </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data_cnt_p</em>&nbsp;</td><td>- number of mac records to ADD/DELETE</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_NO_RESOURCES if FDB hash bin is full. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb0eeaab4331cd32326ea7a4d91303df"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_mac_addr_get" ref="cb0eeaab4331cd32326ea7a4d91303df" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint16_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_entry_type_t&nbsp;</td>
          <td class="paramname"> <em>mac_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_addr_params_t *&nbsp;</td>
          <td class="paramname"> <em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_key_filter_t *&nbsp;</td>
          <td class="paramname"> <em>key_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&nbsp;</td>
          <td class="paramname"> <em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>data_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function reads MAC entries from the SW FDB table, which is exact copy of HW DB on any device. The output supports up to SX_FDB_MAX_GET_ENTRIES entries which is currently 64<p>
The function can receive three types of input:<p>
<ul>
<li>1) get information for current mac + vlan - you should insert mac+vlan data in the key variable, data_cnt should be equal to 1. cmd should be SX_ACCESS_CMD_GET</li></ul>
<p>
<ul>
<li>2) get a list of first n&lt;=64 macs - you should insert mac+vlan data in the key variable, data_cnt should be equal to n, mac_type is a type you want to receive,key_filter is the filter types you want to filter the results by, cmd should be SX_ACCESS_CMD_GET_FIRST</li></ul>
<p>
<ul>
<li>3) get a list of n&lt;=64 macs which comes after certain mac record (it does not have to exist) you should insert mac+vlan data in the key variable, data_cnt should be equal to n, mac_type is a type you want to receive, key_filter is the filter types you want to filter the results by, cmd should be SX_ACCESS_CMD_GETNEXT</li></ul>
<p>
mac_list will return the records info and their quantity in data_cnt for all types of requests.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- get, get_next, get first </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mac_type</em>&nbsp;</td><td>- static, dynamic, all </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key_p</em>&nbsp;</td><td>- mac entry with information for search (mac + vlan) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key_filter_p</em>&nbsp;</td><td>- filter types used on the mac_list<ul>
<li>fid / mac / logical port </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mac_list_p</em>&nbsp;</td><td>- pointer to list </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data_cnt_p</em>&nbsp;</td><td>-number of entries to retrieve, also retrieved number of entries</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch wa const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *max_mc_group_cnt_p s not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="94b95bb23afdb7c76d742d01204e663b"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_count_get" ref="94b95bb23afdb7c76d742d01204e663b" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_count_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>data_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function counts all MAC entries in SW FDB table (static + dynamic).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data_cnt_p</em>&nbsp;</td><td>- retrieved number of entries</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if swid is out of range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5d254f251cfe5a95be3c62891df022c"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_port_count_get" ref="f5d254f251cfe5a95be3c62891df022c" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_port_count_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>data_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the amount of MACs learned on port (static + dynamic).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port ID </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data_cnt_p</em>&nbsp;</td><td>- retrieved number of entries</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if port does not exist <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="332c511da70dea031ab33c65e0b996ec"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_fid_count_get" ref="332c511da70dea031ab33c65e0b996ec" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_fid_count_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>data_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the amount of MACs learned on fid (static + dynamic).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data_cnt_p</em>&nbsp;</td><td>- retrieved number of entries</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if swid does not exist <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if fid/swid is out of range <p>
SX_STATUS_PARAM_NULL if parameter is NULL <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="fff41b0a5d7311d86d929a03811ede6f"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_port_set" ref="fff41b0a5d7311d86d929a03811ede6f" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets/removes limit on the amount of dynamic MACs learned on port.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- SET/DELETE </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port ID </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>limit</em>&nbsp;</td><td>- When SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error. <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if port does not exist <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if limit is out of range <p>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="83ac81748592a275cdaf12afadc33e74"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_fid_set" ref="83ac81748592a275cdaf12afadc33e74" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_fid_t fid, const uint32_t limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets/removes limit on the amount of dynamic MACs learned on FID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- SET/DELETE </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>limit</em>&nbsp;</td><td>- When SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if swid does not exist <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if swid/fid/limit is out of range <p>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="19055e813badb894992902ac11ef6ad4"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_port_get" ref="19055e813badb894992902ac11ef6ad4" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>limit_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the maximum amount of dynamic MACs that can be learned on port.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port ID </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>limit_p</em>&nbsp;</td><td>- The result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if port does not exist <p>
SX_STATUS_PARAM_NULL if parameter is NULL <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d04bf658c8039ca8ed890aab54c6279"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_fid_get" ref="1d04bf658c8039ca8ed890aab54c6279" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fid_t fid, uint32_t *limit_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>limit_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the maximum amount of dynamic MACs that can be learned on FID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>limit_p</em>&nbsp;</td><td>- The result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>sx_status_t: <p>
SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error <p>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error <p>
SX_STATUS_INVALID_HANDLE: Invalid Handle <p>
SX_STATUS_ENTRY_NOT_FOUND if swid does not exist <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if fid/swid is out of range <p>
SX_STATUS_PARAM_NULL if parameter is NULL <p>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div><p>
<a class="anchor" name="af5ddb361a67b1c01f642ef6b10e1348"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_set" ref="af5ddb361a67b1c01f642ef6b10e1348" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint16_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&nbsp;</td>
          <td class="paramname"> <em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&nbsp;</td>
          <td class="paramname"> <em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>port_cnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function adds, deletes MC MAC entries from the FDB. Please Note: MC entry cannot be created and associated with Ports at the same time<p>
NOTE The log_port_list_p list should not contain the logical port items which are specified as Ethernet Port and which are members of LAG port at same time.<p>
When ADD command is requested this function does the following:<ul>
<li>check if MC groups is already created and returns FAILURE if yes;</li><li>allocates and stores the MC group;</li></ul>
<p>
When DELETE command is requested this function does the following:<ul>
<li>for each LEAF device:</li><li>deletes Multicast FDB Records;</li><li>deletes FDB Multicast ID Records;</li><li>deletes SPGT record;</li></ul>
<p>
<ul>
<li>deletes MC group from MCDB;</li><li>returns pgi into the pool.</li></ul>
<p>
When Edit(add_port) command is requested this function does the following:<ul>
<li>updates MCDB for adding logical ports and LAG ports;</li><li>for each LEAF device:<ul>
<li>gets list of LAG member logical ports from LAGLib for all LAG logical ports which are belongs to this MC group;</li><li>updates SPGT record for adding spine, MC members and LAGs member ports;</li><li>adds local ports to FDB Multicast ID Records (if FDB look up by MC ID is allowed on LEAF devices).</li></ul>
</li></ul>
<p>
When Edit(delete_port) command is requested this function does the following:<ul>
<li>updates MCDB for deleting logical ports and LAG ports.</li><li>for each LEAF device:</li><li>updates SPGT record for deleting requested ports (if logical port is a LAG port then all LAG members logical ports will be removed);</li><li>removes local ports from FDB Multicast ID Records (if FDB look up by MC ID is allowed on LEAF devices)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- add/ delete/ add port/ delete port/ test </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group_addr</em>&nbsp;</td><td>- MAC group address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port_list_p</em>&nbsp;</td><td>- a pointer to a port list </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>port_cnt</em>&nbsp;</td><td>- sizeof port list </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_NO_MEMORY if memory allocation failed. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr alreadey added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc49a8d40d62974a94e4d8af60e3f637"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_get" ref="bc49a8d40d62974a94e4d8af60e3f637" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint16_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&nbsp;</td>
          <td class="paramname"> <em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&nbsp;</td>
          <td class="paramname"> <em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>port_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns MC MAC entries data.<p>
NOTE The log_port_list_p list will contain LAG ports id only and not contains LAG members logical ports IDs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group_addr</em>&nbsp;</td><td>- MAC group address </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>log_port_list_p</em>&nbsp;</td><td>- a pointer to a port list </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>port_cnt_p</em>&nbsp;</td><td>- sizeof port list</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_NO_MEMORY if memory allocation failed. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if group_addr was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0d6033f11a7b399dfb5a75213ae2fae"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_max_group_cnt_get" ref="a0d6033f11a7b399dfb5a75213ae2fae" args="(const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *max_mc_group_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_max_group_cnt_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>max_mc_group_cnt_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns MC max group count.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>max_mc_group_cnt_p</em>&nbsp;</td><td>- maximum mc group</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="887cf67a3d1f00041b3e41170992b4e8"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_all_set" ref="887cf67a3d1f00041b3e41170992b4e8" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_all_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function deletes all FDB table on a switch partition.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9908a902076cfa3e01aeea8c1abd4a4e"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_port_set" ref="9908a902076cfa3e01aeea8c1abd4a4e" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_port_log_id_t log_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function deletes the FDB table entries that are related to a flushed port.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2c6745019a8e4699cb1cf4bc4feafe5"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_fid_set" ref="e2c6745019a8e4699cb1cf4bc4feafe5" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_fid_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function deletes all FDB table entries that were learned on the flushed FID<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>filtering DB id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e1eeef31bbde934d1d2ebfdef4c9b58a"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_port_fid_set" ref="e1eeef31bbde934d1d2ebfdef4c9b58a" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_port_log_id_t log_port, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_fid_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function deletes all FDB table entries that were learned on the flushed FID and port.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering DB id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af812deb31ac080087cb525a41a195ec"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_flush_all_set" ref="af812deb31ac080087cb525a41a195ec" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_all_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
const const This function deletes all FDB MC tables on a switch partition.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abc7188f337ed0e95235726c8ea37112"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_flush_fid_set" ref="abc7188f337ed0e95235726c8ea37112" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_fid_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function deletes all FDB MC table entries that were learned on the flushed FID, on a switch partition.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>filtering DB id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a6ce92e0d0b0673f0086b999e6ec139"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_vlan_member_set" ref="7a6ce92e0d0b0673f0086b999e6ec139" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_vlan_member_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&nbsp;</td>
          <td class="paramname"> <em>vid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function maps VLANs to filtering databases for shared vlan learning (SVL) between VLANs. If independent vlan learning is desired, a single VLAN should be mapped to a single FID.<p>
When cmd=add This function adds FID to VID mapping record for selected SWID. When cmd=delete This function deletes FID to VID mapping record from selected SWID. The DEF_FID value will be added to the corresponding VLAN.<p>
NOTE this API performs FDB flushing by FID before FID to VID mapping changing<p>
NOTE only independent learning is supported in the current release.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>- add/ delete </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering DB id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>- VLAN id</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc0557c3946207da8e2d12b2578b33d3"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_learn_mode_set" ref="fc0557c3946207da8e2d12b2578b33d3" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&nbsp;</td>
          <td class="paramname"> <em>learn_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the FDB learning mode per swid It affects all ports and vlans in the swid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>learn_mode</em>&nbsp;</td><td>- new swid's learn mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_NO_MEMORY if memory allocation failed. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a6037a85d5494d60ca656fb4e58679d"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_learn_mode_get" ref="1a6037a85d5494d60ca656fb4e58679d" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&nbsp;</td>
          <td class="paramname"> <em>learn_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets the FDB learning mode per swid<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>learn_mode</em>&nbsp;</td><td>- swid's learn mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_NO_MEMORY if memory allocation failed. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dfcf027836302463584baecffc3fff6"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_learn_rate_limit_set" ref="1dfcf027836302463584baecffc3fff6" args="(const sx_api_handle_t handle, const sx_fdb_learn_limit_cmd_t learn_limit_cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t log_port, const uint16_t rate_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_rate_limit_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_limit_cmd_t&nbsp;</td>
          <td class="paramname"> <em>learn_limit_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>rate_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is not supported at the current release<p>
This function sets the rate that the driver informs application on new address events<p>
If learn_limit_cmd = limit_vlan then the learning rate limit will be updated on all LEAF devices. If limit_port = limit_port then the learning rate limit will be updated on device for which log_port is belonged to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>learn_limit_cmd</em>&nbsp;</td><td>- limit_vlan, limit_port, </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id - should be set to 0 when 'limit_port' command param is set </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>- VLAN id - should be set to 0 when 'limit_port' command param is set </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port - should be set to 0 when 'limit_vlan' command param is set </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rate_limit</em>&nbsp;</td><td>- number of learning events per second</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_NO_MEMORY if memory allocation failed. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c510372668e0d39896fa326b32672765"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_swid_global_learning_mode_set" ref="c510372668e0d39896fa326b32672765" args="(const sx_api_handle_t handle, const sx_swid_id_t swid_id, const sx_fdb_learn_ctrl_t learn_ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_swid_global_learning_mode_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_ctrl_t&nbsp;</td>
          <td class="paramname"> <em>learn_ctrl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API Sets the SwID's Learning parameters into the system's Database.<p>
NOTE only independent learning is supported in the current release.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid_id</em>&nbsp;</td><td>- Switch (virtual) ID (whose parameters to set). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>learn_ctrl</em>&nbsp;</td><td>- Is Independent/Shared Learning &amp; is Roaming Enabled/Disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecf42acf4fbc24b07c606512574bbdec"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_swid_global_learning_mode_get" ref="ecf42acf4fbc24b07c606512574bbdec" args="(const sx_api_handle_t handle, const sx_swid_id_t swid_id, sx_fdb_learn_ctrl_t *learn_ctrl_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_swid_global_learning_mode_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_ctrl_t *&nbsp;</td>
          <td class="paramname"> <em>learn_ctrl_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API Retrieves the SwID's Learning parameters from the system's Database.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid_id</em>&nbsp;</td><td>- Switch (virtual) ID (whose parameters to retrieve). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>learn_ctrl_p</em>&nbsp;</td><td>- Is Independent/Shared Learning &amp; is Roaming Enabled/Disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_PARAM_NULL if parameter is NULL. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f4c2f9dd69de1a5ac743a6ccc81bd24"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_learn_mode_set" ref="9f4c2f9dd69de1a5ac743a6ccc81bd24" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&nbsp;</td>
          <td class="paramname"> <em>learn_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets fid's learn mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- switch id. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering identifier </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>learn</em>&nbsp;</td><td>mode- fid's learn mode </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5f2b448e2c230c0df877611b4b01e51"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_learn_mode_get" ref="c5f2b448e2c230c0df877611b4b01e51" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&nbsp;</td>
          <td class="paramname"> <em>learn_mode_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets fid's learn mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- switch id. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>- filtering identifier </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>learn</em>&nbsp;</td><td>mode- fid's learn mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB <p>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function returns fail <p>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d39c1c5a78a62b690dfbbf131dde373"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_port_learn_mode_set" ref="6d39c1c5a78a62b690dfbbf131dde373" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&nbsp;</td>
          <td class="paramname"> <em>learn_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets port's learn mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>learn</em>&nbsp;</td><td>mode- port's learn mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB <p>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function returns fail <p>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="348fa08614e9de19453041abb9521b05"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_port_learn_mode_get" ref="348fa08614e9de19453041abb9521b05" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&nbsp;</td>
          <td class="paramname"> <em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&nbsp;</td>
          <td class="paramname"> <em>learn_mode_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets port's learn mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>log_port</em>&nbsp;</td><td>- logical port number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>learn</em>&nbsp;</td><td>mode- port's learn mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully <p>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB <p>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function returns fail <p>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="82513c8c8099e62fbb226b62ce5521cd"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_notify_params_set" ref="82513c8c8099e62fbb226b62ce5521cd" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_fdb_notify_params_t *notify_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_set           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_notify_params_t *&nbsp;</td>
          <td class="paramname"> <em>notify_params_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets FDB notify parameters. This only affects when controlled learn mode is set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params_p</em>&nbsp;</td><td>- new notify params</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5db2340bb3e3c83fc6ba52ca8167a45"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_notify_params_get" ref="b5db2340bb3e3c83fc6ba52ca8167a45" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, sx_fdb_notify_params_t *notify_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_get           </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&nbsp;</td>
          <td class="paramname"> <em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_notify_params_t *&nbsp;</td>
          <td class="paramname"> <em>notify_params_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets FDB notify parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>- SX-API handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>swid</em>&nbsp;</td><td>- virtual switch partition id </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>- swid's notify params</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. <p>
SX_STATUS_INVALID_HANDLE if NULL handle received. <p>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. <p>
SX_STATUS_ENTRY_NOT_FOUND if switch was not added. <p>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div><p>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Sun Jan 26 16:59:25 2014 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
