<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX API Guide: sdk/sx_api_acl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX API Guide&#160;<span id="projectnumber">4.1.5000</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>SwitchX&#160;SDK&#160;API&#160;Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_acl.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__acl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aadfc89bd1ed719720aef093a6d27aef0">sx_api_acl_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1b19d38aaad622638cc25ffc1e861e53">sx_api_acl_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#abeff59071f650e6e79d3d84a2466aef1">sx_api_acl_region_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_type_t key_type, const sx_acl_action_type_t action_type, const sx_acl_size_t region_size, sx_acl_region_id_t *region_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6b49b3d09fd3e0e105abe4927a5c602d">sx_api_acl_region_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_key_type_t *key_type_p, sx_acl_action_type_t *action_type_p, sx_acl_size_t *region_size_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3d3eac6c48940390d6b9fbd8e4c9326c">sx_api_acl_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_type_t acl_type, const sx_acl_direction_t acl_direction, const sx_acl_region_group_t *acl_region_group_p, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a21db595169c45f866832b88844cb9f1f">sx_api_acl_get</a> (const sx_api_handle_t handle, const sx_acl_id_t acl_id, sx_acl_type_t *acl_type_p, sx_acl_direction_t *acl_direction_p, sx_acl_region_group_t *acl_region_group_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#acc922fb9cf64214d703db802ca91bf32">sx_api_acl_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_direction_t acl_direction, const sx_acl_id_t *acl_id_list_p, const uint32_t acl_id_cnt, sx_acl_id_t *group_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab7ecf2ea6914f57c8b24fc288b6aec40">sx_api_acl_group_get</a> (const sx_api_handle_t handle, const sx_acl_id_t group_id, sx_acl_direction_t *acl_direction_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af7f1841f9e865b353f5dc6742212b4a0">sx_api_acl_policy_based_switching_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_entry_t *pbs_entry_p, sx_acl_pbs_id_t *pbs_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1d3627a7131f363300617de31f7edc3b">sx_api_acl_policy_based_switching_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_id_t pbs_id, sx_acl_pbs_entry_t *pbs_entry_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1395c6e1613b712e9854f4e982ff8a62">sx_api_acl_l4_port_range_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_entry_t *l4_port_range_p, sx_acl_port_range_id_t *range_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ad1c17eb4b9b274fddb09c13f1514c289">sx_api_acl_l4_port_range_get</a> (const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_port_range_entry_t *l4_port_range_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a85de9c7f09f1494b0af588835ba5febb">sx_api_acl_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_t *rules_list_p, const uint32_t rules_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8a71f177218829d87debe98d4c399238">sx_api_acl_rules_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t start_offset, sx_acl_rule_t *rules_list_p, uint32_t *rules_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aae2d4dde1a42506c57445dedaa2934d7">sx_api_acl_rule_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t rule_offset, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a022e95843912425808dcbb26058e6c5f">sx_api_acl_rule_block_move_set</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t block_start, const sx_acl_size_t block_size, const sx_acl_rule_offset_t new_block_start)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a92286cc3f4baf42e3f97ad25c380ffb6">sx_api_acl_port_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_acl_id_t acl_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a9543188e428bed340f419ed050a47277">sx_api_acl_port_bind_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6cfe4cc96f0de7b65e2a46603fc1b78a">sx_api_acl_vlan_group_map_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_vlan_id_t *vlan_list_p, const uint32_t vlan_cnt, sx_acl_vlan_group_t *group_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2943e03e105609c89d70865940ddf9c4">sx_api_acl_vlan_group_map_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_acl_vlan_group_t group_id, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3f5727bed5f37c11a2691483d3f368c9">sx_api_acl_vlan_group_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_vlan_group_t vlan_group, const sx_acl_id_t acl_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab91d548d2e1386edee4e5e4fd6c0813a">sx_api_acl_vlan_group_bind_get</a> (const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aadfc89bd1ed719720aef093a6d27aef0"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_log_verbosity_level_set" ref="aadfc89bd1ed719720aef093a6d27aef0" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the log verbosity level of ACL MODULE </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a1b19d38aaad622638cc25ffc1e861e53"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_log_verbosity_level_get" ref="a1b19d38aaad622638cc25ffc1e861e53" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the log verbosity level of ACL MODULE</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="abeff59071f650e6e79d3d84a2466aef1"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_region_set" ref="abeff59071f650e6e79d3d84a2466aef1" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_type_t key_type, const sx_acl_action_type_t action_type, const sx_acl_size_t region_size, sx_acl_region_id_t *region_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_action_type_t&#160;</td>
          <td class="paramname"><em>action_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>region_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_id_t *&#160;</td>
          <td class="paramname"><em>region_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to create ACL region (rules list). for creation use command CREATE and supply key_type and size. acl_region_id is returned on successful creation. for destroying an ACL region it is required that the ACL region is not bound and the acl_region_id should be provided. EDIT command is used for resizing an existing ACL region. acl_region_id and new size should be provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY / EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_type</td><td>- key type used in this ACL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action_type</td><td>- type of actions to be used in this ACL block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_size</td><td>- maximal number of rules in this ACL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">region_id_p</td><td>- ACL region ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a6b49b3d09fd3e0e105abe4927a5c602d"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_region_get" ref="a6b49b3d09fd3e0e105abe4927a5c602d" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_key_type_t *key_type_p, sx_acl_action_type_t *action_type_p, sx_acl_size_t *region_size_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_type_t *&#160;</td>
          <td class="paramname"><em>key_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_action_type_t *&#160;</td>
          <td class="paramname"><em>action_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_size_t *&#160;</td>
          <td class="paramname"><em>region_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL region properties .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_type_p</td><td>- key type used in this ACL region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">action_type_p</td><td>- type of actions used in this ACL region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">region_size_p</td><td>- maximal number of rules in this ACL region</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3eac6c48940390d6b9fbd8e4c9326c"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_set" ref="a3d3eac6c48940390d6b9fbd8e4c9326c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_type_t acl_type, const sx_acl_direction_t acl_direction, const sx_acl_region_group_t *acl_region_group_p, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_type_t&#160;</td>
          <td class="paramname"><em>acl_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to create a single region ACL. Use CREATE access command for creating a new ACL, it will return an ACL id. DESTROY command may be used when the ACL is not bound to HW. Packet sensitive ACL is currently NOT supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_type</td><td>- ACL type of this ACL (AGNOSTIC). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction (ingress or egress ACL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group matching ACL type </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- ACL ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a21db595169c45f866832b88844cb9f1f"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_get" ref="a21db595169c45f866832b88844cb9f1f" args="(const sx_api_handle_t handle, const sx_acl_id_t acl_id, sx_acl_type_t *acl_type_p, sx_acl_direction_t *acl_direction_p, sx_acl_region_group_t *acl_region_group_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_type_t *&#160;</td>
          <td class="paramname"><em>acl_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL attributes . The ACL id is given and the function returns ACL attributes : type and a list of attached regions. the length of the regions list depends on the ACL type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_type_p</td><td>- ACL type (packet agnostic or packet sensitive) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction_p</td><td>- ACL direction (ingress or egress ACL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group attached to the ACL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="acc922fb9cf64214d703db802ca91bf32"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_group_set" ref="acc922fb9cf64214d703db802ca91bf32" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_direction_t acl_direction, const sx_acl_id_t *acl_id_list_p, const uint32_t acl_id_cnt, sx_acl_id_t *group_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>acl_id_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for controlling a group of ACL or in other words cascaded ACL blocks up to the size of SX_ACL_MAX_ACL_GROUP_SIZE. When using CREATE command user must supply the ACL group direction. A new group is allocated and a free group ID is returned. Use SET command to define an ordered cascaded ACLs group (ACLs must be in the same direction as the group). SET Can be also used for editing an ACL group. DESTROY command will free the list resource. It is allowed only when the ACL list is not bound in HW.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / SET / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL group direction (ingress or egress ACLs). All ACLs in this group must have the same direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_list_p</td><td>- ordered list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_cnt</td><td>- number of elements in the list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- ACL group ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no group is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="ab7ecf2ea6914f57c8b24fc288b6aec40"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_group_get" ref="ab7ecf2ea6914f57c8b24fc288b6aec40" args="(const sx_api_handle_t handle, const sx_acl_id_t group_id, sx_acl_direction_t *acl_direction_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL group attributes . the ACL group id is given and the function returns ACL group attributes : direction and a list of attached ACLs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- ACL group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction</td><td>- ACL direction (ingress or egress ACL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_list_p</td><td>- list of the group ACL IDs. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_cnt_p</td><td>- In - size of the ACL IDs array, OUT - number of valid ACL IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="af7f1841f9e865b353f5dc6742212b4a0"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_policy_based_switching_set" ref="af7f1841f9e865b353f5dc6742212b4a0" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_entry_t *pbs_entry_p, sx_acl_pbs_id_t *pbs_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_id_t *&#160;</td>
          <td class="paramname"><em>pbs_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/edits/deletes a policy based switching (PBS) set . Policy based switching entry can be later bound to an ACL rule in order to specify destination port/port group (multicast) or send the frame to the router block / fcf block. Use ADD command to create a PBS entry, note that this operation may fail if no HW resources are available. PBS entry can be created without ports in order to ensure future HW resource availability. Use ADD_PORTS and DELETE_PORTS access command to edit the entry</p>
<ul>
<li>unicast entry can have up to 1 port only. Use DELETE command to clear a PBS record (not allowed when this record is in use by ACL rules)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / ADD_PORTS / DELETE_PORTS / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_entry</td><td>- struct for PBS attributes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any inpu parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter exceeds its allowed range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no HW resources for PBS creation </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if the PBS record is in use </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a1d3627a7131f363300617de31f7edc3b"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_policy_based_switching_get" ref="a1d3627a7131f363300617de31f7edc3b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_id_t pbs_id, sx_acl_pbs_entry_t *pbs_entry_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_id_t&#160;</td>
          <td class="paramname"><em>pbs_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get a PBS set or to count ports of a PBS set. note that for GET command the pbs_entry should be pre-allocated and pbs_entry port_num should be updated to maximal port count to get.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- COUNT / GET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID of the PBS entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_id</td><td>- Port based switching entry ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_entry</td><td>- struct for Policy based switching entry attributes. IN - max port number to retrieve. OUT</p>
<ul>
<li>actual number of ports retrieved.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any of the input parameters are NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter exceeds its allowed range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a1395c6e1613b712e9854f4e982ff8a62"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_l4_port_range_set" ref="a1395c6e1613b712e9854f4e982ff8a62" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_entry_t *l4_port_range_p, sx_acl_port_range_id_t *range_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_id_t *&#160;</td>
          <td class="paramname"><em>range_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/edits/deletes a Layer 4 port range comparison set (up to SX_ACL_MAX_PORT_RANGES). Use this comparison set for ACL IPv4 IPv6 full key. When ADD command is used the given ranges are written into a group and its ID is returned. When EDIT command is used the given range is written into a group of range_index. When DELETE command is used the given range_index configuration is cleared. Port range comparison set cannot be deleted if it is applied to an acl rule.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / EDIT / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="ad1c17eb4b9b274fddb09c13f1514c289"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_l4_port_range_get" ref="ad1c17eb4b9b274fddb09c13f1514c289" args="(const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_port_range_entry_t *l4_port_range_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_id_t&#160;</td>
          <td class="paramname"><em>range_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get a Layer 4 port range comparison set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id</td><td>- Port range comparison ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a85de9c7f09f1494b0af588835ba5febb"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_rules_set" ref="a85de9c7f09f1494b0af588835ba5febb" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_t *rules_list_p, const uint32_t rules_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rules_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for inserting rules into an ACL region. Inserting rules is allowed before and after bind operation. Rule is inserted to an explicit offset, overriding existing rule on that offset. Rules must have the same key type as the ACL region.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) in rules[].key.fields.key_type.vid (if present in the key_type) and rules[].mask.fields.key_type.vid (if present) and rules[].action.basic_action.vid (if present), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_p</td><td>- array of structs representing rule content. should be in size of num_of_rules </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_rules</td><td>- number of rules to configure (number of elements in the array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no more space for rules </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a8a71f177218829d87debe98d4c399238"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_rules_get" ref="a8a71f177218829d87debe98d4c399238" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t start_offset, sx_acl_rule_t *rules_list_p, uint32_t *rules_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rules_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting rules of an ACL block.</p>
<p>When in 802.1D mode, instead of receiving a vid(Vlan ID), on rules[].key.fields.key_type.vid, rules[].mask.fields.key_type.vid and rules[].action.basic_action.vid, a bridge_id's are provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_offset</td><td>- Start offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rules_p</td><td>- pointer to array of structs representing rule content. should be in size of num_of_rules. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">num_of_rules</td><td>- IN - number of rules to get (number of elements in the array), OUT - number of rules that were actually read from ACL table</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure requested </dd></dl>

</div>
</div>
<a class="anchor" id="aae2d4dde1a42506c57445dedaa2934d7"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_rule_activity_get" ref="aae2d4dde1a42506c57445dedaa2934d7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t rule_offset, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>rule_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting rules of an ACL block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule_offset</td><td>- ACL Rule offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- ACL Rule activity</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure requested </dd></dl>

</div>
</div>
<a class="anchor" id="a022e95843912425808dcbb26058e6c5f"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_rule_block_move_set" ref="a022e95843912425808dcbb26058e6c5f" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t block_start, const sx_acl_size_t block_size, const sx_acl_rule_offset_t new_block_start)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_block_move_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>new_block_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for moving a block of rules within an ACL region. Moving is allowed before and after ACL bind. Moving a block does not affect search hits, but may override existing rules if such exist on the new block location. Non-valid rules within the block are moved as well.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_start</td><td>- Rules block start offset within the ACL block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>- Number of rules to move within the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block_start</td><td>- New offset of the first rule of the given rules block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd></dl>

</div>
</div>
<a class="anchor" id="a92286cc3f4baf42e3f97ad25c380ffb6"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_port_bind_set" ref="a92286cc3f4baf42e3f97ad25c380ffb6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_acl_id_t acl_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to bind/unbind ACL or ACL group to a port (or LAG). Binding more than one ACL to port may be achieved by using ACL groups. Binding may fail if there is no place for the ACL in HW</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID given for ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a9543188e428bed340f419ed050a47277"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_port_bind_get" ref="a9543188e428bed340f419ed050a47277" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or ACL group which is bound to a specific port</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port is not bound </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfe4cc96f0de7b65e2a46603fc1b78a"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_vlan_group_map_set" ref="a6cfe4cc96f0de7b65e2a46603fc1b78a" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_vlan_id_t *vlan_list_p, const uint32_t vlan_cnt, sx_acl_vlan_group_t *group_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vlan_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_vlan_group_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for controlling mapping of vlans into vlan groups for ACL binding. CREATE command used for creating a new group, will return a free group ID if such exist ADD / DELETE commands are used to control mapping of SWID,VID to an existing vlan group DESTROY command is used to free a vlan group resource</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / ADD / DELETE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID (used only with ADD/DELETE) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_list</td><td>- a list of vlans to attach to this group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_num</td><td>- number of elements in the vlan list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no group is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a2943e03e105609c89d70865940ddf9c4"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_vlan_group_map_get" ref="a2943e03e105609c89d70865940ddf9c4" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_acl_vlan_group_t group_id, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting the current mapping of vlans into vlan groups for ACL binding. the vlan_list parameter are arrays at the size of vlan_num which is filled by this function. the actual size is then returned as output.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_list</td><td>- list of vlans which are members in this vlan group (in the given SWID) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vlan_num</td><td>- IN - number of elements allocated in the mapping entries arrays, OUT - number of actual elements found</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="a3f5727bed5f37c11a2691483d3f368c9"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_vlan_group_bind_set" ref="a3f5727bed5f37c11a2691483d3f368c9" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_vlan_group_t vlan_group, const sx_acl_id_t acl_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to bind/unbind ACL to vlan group. Binding more than one ACL to vlan group is allowed. Binding may fail if there is no place for the ACL in HW</p>
<p>When in 802.1D mode, instead of providing a Vlan group, you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- logical port ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID of an ACL or ACL list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="ab91d548d2e1386edee4e5e4fd6c0813a"></a><!-- doxytag: member="sx_api_acl.h.sx_api_acl_vlan_group_bind_get" ref="ab91d548d2e1386edee4e5e4fd6c0813a" args="(const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or ACL group which is bound to a specific vlan group</p>
<p>When in 802.1D mode, instead of providing a Vlan group, you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- vlan_group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if vlan group is not bound </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Sun Feb 22 2015 10:07:48 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
