<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX API Guide: sdk/sx_api_router.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX API Guide&#160;<span id="projectnumber">4.1.5000</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>SwitchX&#160;SDK&#160;API&#160;Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_router.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__router_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a34f17bf4bcc4feeac94a3dad937ac9ef">sx_api_router_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a16054cd7f48ec56a42953a3b38dfd4b3">sx_api_router_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ac828368205f9110cb12ce1efaa127e36">sx_api_router_ecmp_hash_params_set</a> (const sx_api_handle_t handle, const sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24b800ec0358c5525688d2d430c409a6">sx_api_router_ecmp_hash_params_get</a> (const sx_api_handle_t handle, sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1ef69aecaf04fa448db5bca24195b338">sx_api_router_init_set</a> (const sx_api_handle_t handle, const sx_router_general_param_t *general_params_p, const sx_router_resources_param_t *router_resource_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2e1cae9d18872c0657706f776130f2cf">sx_api_router_deinit_set</a> (const sx_api_handle_t handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2dc149f2962ae58006fe5d99c30f2170">sx_api_router_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_attributes_t *router_attr, sx_router_id_t *vrid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2c3deff6c205855116423b65854ddaff">sx_api_router_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, sx_router_attributes_t *router_attr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa75e9b0a9cb41809d2b7158ad9742e88">sx_api_router_interface_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_router_interface_param_t *ifc_p, const sx_interface_attributes_t *ifc_attr_p, sx_router_interface_t *rif_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a726222b37bb531286106877b469ee77d">sx_api_router_interface_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_id_t *vrid_p, sx_router_interface_param_t *ifc_p, sx_interface_attributes_t *ifc_attr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8e7036a60c1a30149df0849edcf4b1cf">sx_api_router_interface_state_set</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, const sx_router_interface_state_t *rif_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#afca9be4809b7930481b23d13b62260c4">sx_api_router_interface_state_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_interface_state_t *rif_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a45fa8aa8bb1a944fc76388b380d32e48">sx_api_router_interface_mac_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_mac_addr_t *mac_addr_list_p, const uint32_t mac_addr_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a6cfa5bcd99c9b86516cdbf088bbc4270">sx_api_router_interface_mac_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_mac_addr_t *mac_addr_list_p, uint32_t *mac_addr_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a022ee237826231f31e9a1a1d13ab49ef">sx_api_router_neigh_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *ip_addr_p, const sx_neigh_data_t *neigh_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ac4540e88aaf73eec57cec641ee36a5c0">sx_api_router_neigh_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *neigh_key_p, const sx_neigh_filter_t *filter_p, sx_neigh_get_entry_t *neigh_entry_list_p, uint32_t *neigh_entry_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a63ed4c91167028e33484e57aa010360e">sx_api_router_neigh_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *ip_addr_p, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a567fd03de370a075336735995e17e77b">sx_api_router_uc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_data_t *uc_route_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a7e7840f0e1e453e677668b9f652c66fc">sx_api_router_uc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_key_filter_t *filter_p, sx_uc_route_get_entry_t *uc_route_get_entries_list_p, uint32_t *uc_route_get_entries_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a059c220b2a25fb94729c83688e7f8ff0">sx_api_router_uc_route_operational_ecmp_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_uc_route_get_entry_t *oper_uc_route_entries_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a472c9bb573ce5a76a04f14cd53346b6f">sx_api_router_counter_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_router_counter_id_t *counter_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a71f2d9f69205e6835bd4290703106121">sx_api_router_interface_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, const sx_router_interface_t rif)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa81e1f46c5501aee769e56e4fa4ebf23">sx_api_router_interface_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, sx_router_interface_t *rif_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab4c18223f082f72efeb16ef6ab4545c6">sx_api_router_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, sx_router_counter_set_t *counter_set_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1c3d7ede0cc2b4a383aacf414c9d84a3">sx_api_router_counter_clear_set</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, const boolean_t all)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a05d61bfefa542ba2654a66e3abedba58">sx_api_router_mc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_mc_route_attributes_t *mc_router_attr_p, const sx_mc_route_data_t *mc_route_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24a37e74c648d6bd3de469df8cbd5b8c">sx_api_router_mc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_mc_route_key_filter_t *filter_p, sx_mc_route_get_entry_t *mc_route_get_entries_list_p, uint32_t *mc_route_get_entries_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab70bf9ca856f55a88e7dd5a4fe5f77fa">sx_api_router_mc_route_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a49d704b1d7e401edc59dde5aff4bf376">sx_api_router_mc_egress_rif_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_router_interface_t *egress_rif_list_p, const uint32_t egress_rif_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a530c3fdb5083d5c3a8f8e74ee348da69">sx_api_router_mc_egress_rif_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_router_interface_t *egress_rif_list_p, uint32_t *egress_rif_cnt)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a34f17bf4bcc4feeac94a3dad937ac9ef"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_log_verbosity_level_set" ref="a34f17bf4bcc4feeac94a3dad937ac9ef" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the log verbosity level of ROUTER MODULE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a16054cd7f48ec56a42953a3b38dfd4b3"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_log_verbosity_level_get" ref="a16054cd7f48ec56a42953a3b38dfd4b3" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the log verbosity level of ROUTER MODULE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ac828368205f9110cb12ce1efaa127e36"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_ecmp_hash_params_set" ref="ac828368205f9110cb12ce1efaa127e36" args="(const sx_api_handle_t handle, const sx_router_ecmp_hash_params_t *ecmp_hash_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the ECMP hash function configuration parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_hash_param_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a24b800ec0358c5525688d2d430c409a6"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_ecmp_hash_params_get" ref="a24b800ec0358c5525688d2d430c409a6" args="(const sx_api_handle_t handle, sx_router_ecmp_hash_params_t *ecmp_hash_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the ECMP hash function configuration parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ef69aecaf04fa448db5bca24195b338"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_init_set" ref="a1ef69aecaf04fa448db5bca24195b338" args="(const sx_api_handle_t handle, const sx_router_general_param_t *general_params_p, const sx_router_resources_param_t *router_resource_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_general_param_t *&#160;</td>
          <td class="paramname"><em>general_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_resources_param_t *&#160;</td>
          <td class="paramname"><em>router_resource_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function Initiates the router module in SDK. uc_params-&gt;ipv4_num requires a value larger than 30. mc_params-&gt;mc_routes-&gt;ipv4_num requires a value larger than 30. (If mc_router is enabled).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">general_params_p</td><td>- general router parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_resource_p-</td><td>router resource parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS - if operation completes successfully. </dd>
<dd>
SX_STATUS_ALREADY_INITIALIZED - When router is already initialized. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE - When calling with bad parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e1cae9d18872c0657706f776130f2cf"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_deinit_set" ref="a2e1cae9d18872c0657706f776130f2cf" args="(const sx_api_handle_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This api deinit's the router block in the sdk.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE When router is still active. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dc149f2962ae58006fe5d99c30f2170"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_set" ref="a2dc149f2962ae58006fe5d99c30f2170" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_attributes_t *router_attr, sx_router_id_t *vrid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes a virtual router. The router ID is allocated and returned to the caller when cmd is ADD, otherwise it is given by the caller. All interfaces and routes associated with a router must be deleted before the router can be deleted as well.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_attr</td><td>- Router attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrid</td><td>- Virtual router ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources to create another router </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router has interfaces or routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3deff6c205855116423b65854ddaff"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_get" ref="a2c3deff6c205855116423b65854ddaff" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, sx_router_attributes_t *router_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a virtual router information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">router_attr</td><td>- Router attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75e9b0a9cb41809d2b7158ad9742e88"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_set" ref="aa75e9b0a9cb41809d2b7158ad9742e88" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_router_interface_param_t *ifc_p, const sx_interface_attributes_t *ifc_attr_p, sx_router_interface_t *rif_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/modifies/deletes/delete_all a router interface. A router interface is associated with L2 interface.</p>
<p>When in 802.1D mode, if ifc_p of type SX_L2_INTERFACE_TYPE_VLAN is provided, instead of providing ifc.vlan.vlan you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/EDIT/DELETE/DELETE ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no interface is available to create. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router interface has routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a726222b37bb531286106877b469ee77d"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_get" ref="a726222b37bb531286106877b469ee77d" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_id_t *vrid_p, sx_router_interface_param_t *ifc_p, sx_interface_attributes_t *ifc_attr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router interface information.</p>
<p>When in 802.1D mode, if ifc_p of type SX_L2_INTERFACE_TYPE_VLAN is returned, instead of receiving a vlan ID on ifc.vlan.vlan, a bridge ID is provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrid_p</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e7036a60c1a30149df0849edcf4b1cf"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_state_set" ref="a8e7036a60c1a30149df0849edcf4b1cf" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, const sx_router_interface_state_t *rif_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets admin state of a router interface. Admin state is set per IP protocol.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="afca9be4809b7930481b23d13b62260c4"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_state_get" ref="afca9be4809b7930481b23d13b62260c4" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_interface_state_t *rif_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets admin state of a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a45fa8aa8bb1a944fc76388b380d32e48"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_mac_set" ref="a45fa8aa8bb1a944fc76388b380d32e48" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_mac_addr_t *mac_addr_list_p, const uint32_t mac_addr_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mac_addr_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes a MAC address from a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_cnt</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfa5bcd99c9b86516cdbf088bbc4270"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_mac_get" ref="a6cfa5bcd99c9b86516cdbf088bbc4270" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_mac_addr_t *mac_addr_list_p, uint32_t *mac_addr_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mac_addr_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets MAC address of a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_addr_cnt_p</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a022ee237826231f31e9a1a1d13ab49ef"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_neigh_set" ref="a022ee237826231f31e9a1a1d13ab49ef" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *ip_addr_p, const sx_neigh_data_t *neigh_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_data_t *&#160;</td>
          <td class="paramname"><em>neigh_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes/delete_all a neighbour information. The neighbour information associate an IP address to a MAC address. The neighbour IP addresses are learned via ARP/ND discovery at the control protocols layer, the interface that the neighbours are associated with is derived from the IP interface configuration. When calling with DELETE command, neigh_data_p-&gt;rif parameter is ignored. When cmd = DELETE_ALL, all neighbors which match the ip_addr.version and the neigh_data_p-&gt;rif, will be deleted. In case rif is SX_ROUTER_INTERFACE_DONTCARE, all neighbors corresponding with the ip_addr.version will be deleted. If ip_addr.version = SX_IP_VERSION_NONE then only IPv4 neighbors will be deleted.</p>
<p>In case action is not SX_ROUTER_ACTION_FORWARD/SX_ROUTER_ACTION_DROP Trap ID will be set to SX_TRAP_ID_L3_NEIGH_IP_BASE + trap priority.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr</td><td>- IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_data_p</td><td>- Neighbours information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbour was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no neighbour entry is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4540e88aaf73eec57cec641ee36a5c0"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_neigh_get" ref="ac4540e88aaf73eec57cec641ee36a5c0" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *neigh_key_p, const sx_neigh_filter_t *filter_p, sx_neigh_get_entry_t *neigh_entry_list_p, uint32_t *neigh_entry_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>neigh_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_neigh_get_entry_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the neighbors whose ip version (IPv4/6) match's the neigh_key_p.ip_addr.version. If neigh_key_p.ip_addr.version == SX_IP_VERSION_NONE then only IPv4 neighbors will be returned. MAC address and Router Interface ID will be returned in case the neighbor exists.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) get information for current ip address - you should insert the ip address in the key variable. neigh_entry_cnt_p should be equal to 1. cmd should be SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>2) get a list of first n&lt;=64 neighs - you should insert ip address data in the key variable. neigh_entry_cnt_p should be equal to n. filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GET_FIRST.</li>
</ul>
<ul>
<li>3) get a list of n&lt;=64 MACs which comes after certain neight record (it does not have to exist) you should insert neight ip address in the key variable. neigh_entry_cnt_p should be equal to n s , filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/ GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_key_p</td><td>- neigh key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- neigh key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_entry_list_p</td><td>- found neigh entries arr </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh_entry_cnt_p</td><td>- found neigh entries num</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbour was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ed4c91167028e33484e57aa010360e"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_neigh_activity_get" ref="a63ed4c91167028e33484e57aa010360e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_addr_t *ip_addr_p, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets and clean neighbor activity information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr_p</td><td>- neigh IP address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- activity .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a567fd03de370a075336735995e17e77b"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_uc_route_set" ref="a567fd03de370a075336735995e17e77b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_data_t *uc_route_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_data_t *&#160;</td>
          <td class="paramname"><em>uc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes an unicast route into the routing table. The route is composed of network address and next hop array which may contains more than one entry for ECMP. In case the ARP entry is not known yet, a route can be added with action other than FORWARD. Upon ARP entry resolved and configured, the route can be modified into FORWARD. In case ARP is unresolved trap priority is set to SX_TRAP_PRIORITY_LOW. Calling with SET cmd will replace all next hop entries associated with the route. (If the route does not exist, it will be created). When cmd = DELETE_ALL all routes matching vrid, and network_addr will be deleted.</p>
<p>Command SOFT_ADD is different from ADD. SOFT_ADD cmd - the function will return in the uc_route_data_p-&gt;next_hop list the actual ECMP that as been configured to HW please note that the actual ECMP may be different from the requested ECMP due to lack of HW resources.</p>
<p>In case action is not SX_ROUTER_ACTION_FORWARD/SX_ROUTER_ACTION_DROP, Trap ID will be set to SX_TRAP_ID_L3_UC_IP_BASE + trap priority.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/SET/SOFT_ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uc_route_data_p</td><td>- route data {Next hop list,action}</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7840f0e1e453e677668b9f652c66fc"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_uc_route_get" ref="a7e7840f0e1e453e677668b9f652c66fc" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_key_filter_t *filter_p, sx_uc_route_get_entry_t *uc_route_get_entries_list_p, uint32_t *uc_route_get_entries_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a unicast route information from the routing table. The function can receive four types of input:</p>
<ul>
<li>1) get information for current ip address - you should insert the ip prefix the key variable. uc_route_get_entries_cnt_p should be equal to 1. cmd should be SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>2) count the number of IPv4/6 UC routes configured, according to the network_addr-&gt;version parameter. uc_route_get_entries_cnt_p should be equal to 0. cmd should be SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>3) get a list of first n&lt;=64 routes - you should insert ip prefix data in the key variable. uc_route_get_entries_cnt_p should be equal to n. filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GET_FIRST.</li>
</ul>
<ul>
<li>4) get a list of n&lt;=64 routes which comes after certain ip prefix (it does not have to exist) you should insert ip prefix address in the address network_addr_p variable. uc_route_get_entries_cnt_p should be equal to n s , filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET /GET_FIRST/ GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- UC route key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>found uc route entries arr . </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>found uc route entries num .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if UC route was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a059c220b2a25fb94729c83688e7f8ff0"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_uc_route_operational_ecmp_get" ref="a059c220b2a25fb94729c83688e7f8ff0" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_uc_route_get_entry_t *oper_uc_route_entries_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_operational_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>oper_uc_route_entries_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves active unicast ECMP route information from the routing table. When using oper_uc_route_entries_p-&gt;route_data.next_hop_cnt=0 only the number of next hops will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_uc_route_entries_p</td><td>- found uc route entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ECMP UC route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a472c9bb573ce5a76a04f14cd53346b6f"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_counter_set" ref="a472c9bb573ce5a76a04f14cd53346b6f" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_router_counter_id_t *counter_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates/destroys a router counter. A router counter should be bound later to a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter_p</td><td>- Router counter ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no counter is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a71f2d9f69205e6835bd4290703106121"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_counter_bind_set" ref="a71f2d9f69205e6835bd4290703106121" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, const sx_router_interface_t rif)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function binds/unbinds a router counter to a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa81e1f46c5501aee769e56e4fa4ebf23"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_interface_counter_bind_get" ref="aa81e1f46c5501aee769e56e4fa4ebf23" args="(const sx_api_handle_t handle, const sx_router_counter_id_t counter, sx_router_interface_t *rif_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router counter bind of a router interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rif_p</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter was not bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4c18223f082f72efeb16ef6ab4545c6"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_counter_get" ref="ab4c18223f082f72efeb16ef6ab4545c6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, sx_router_counter_set_t *counter_set_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_set_t *&#160;</td>
          <td class="paramname"><em>counter_set_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router counter. When using cmd=READ_CLEAR, the counters will be returned and cleared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_set_p</td><td>- Router counter set values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c3d7ede0cc2b4a383aacf414c9d84a3"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_counter_clear_set" ref="a1c3d7ede0cc2b4a383aacf414c9d84a3" args="(const sx_api_handle_t handle, const sx_router_counter_id_t counter, const boolean_t all)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_clear_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears router counter set of a router counter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>- Clear all Router counters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a05d61bfefa542ba2654a66e3abedba58"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_mc_route_set" ref="a05d61bfefa542ba2654a66e3abedba58" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_mc_route_attributes_t *mc_router_attr_p, const sx_mc_route_data_t *mc_route_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_attributes_t *&#160;</td>
          <td class="paramname"><em>mc_router_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_data_t *&#160;</td>
          <td class="paramname"><em>mc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/modifies/deletes a multicast route into the MC routing table.</p>
<p>In case action is not SX_ROUTER_ACTION_FORWARD/SX_ROUTER_ACTION_DROP, Trap ID will be set to SX_TRAP_ID_L3_MC_IP_BASE + trap priority.</p>
<p>In case mc_router_attr_p-&gt;rpf_action is SX_ROUTER_RPF_ACTION_TRAP, the caller should configure SX_TRAP_ID_ETH_L3_RPF trap first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/MODIFY/DELETE/DELETE_ALL DELETE_ALL command deletes all multicast routes associated with vrid and source_addr.version. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route enntry key {Source IP Address,group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_router_attr_p</td><td>-multicast route attribute (e.g. rpf mode,ttl ... ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_data_p</td><td>- Route data {action , egrees rif list}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a24a37e74c648d6bd3de469df8cbd5b8c"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_mc_route_get" ref="a24a37e74c648d6bd3de469df8cbd5b8c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_mc_route_key_filter_t *filter_p, sx_mc_route_get_entry_t *mc_route_get_entries_list_p, uint32_t *mc_route_get_entries_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a multicast route from the MC routing table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET GET - Get multicast route entry from DB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route enntry key {Source IP Address,group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- MC route key_filter - Currently NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>found mc route entries arr . </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>found mc route entries num .</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mc_router_attr_p</td><td>-multicast route route attribute (e.g. rpf mode,ttl ... ) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mc_route_data_p</td><td>- Route data {action , egrees rif list} .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab70bf9ca856f55a88e7dd5a4fe5f77fa"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_mc_route_activity_get" ref="ab70bf9ca856f55a88e7dd5a4fe5f77fa" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads and clears multicast route activity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route enntry key {Source IP Address,group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- Route activity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a49d704b1d7e401edc59dde5aff4bf376"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_mc_egress_rif_set" ref="a49d704b1d7e401edc59dde5aff4bf376" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_router_interface_t *egress_rif_list_p, const uint32_t egress_rif_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/modifies/deletes an egress VLAN/PORT interfaces to multicast route.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL DELETE_ALL command deletes all egress router interfaces associated with multicast group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route enntry key {Source IP Address,group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">egress_rif_cnt</td><td>- Egress Router Interface array num.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a530c3fdb5083d5c3a8f8e74ee348da69"></a><!-- doxytag: member="sx_api_router.h.sx_api_router_mc_egress_rif_get" ref="a530c3fdb5083d5c3a8f8e74ee348da69" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_router_interface_t *egress_rif_list_p, uint32_t *egress_rif_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function get an egress VLAN/PORT interfaces from multicast route. When egress_rif_num is 0 , will return a counter of the number of egress rifs, and egress_rif_arr will remain empty. When egress_rif_arr = NULL, will return counter in egress_rif_num.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route enntry key {Source IP Address,group address, ingress rif } </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">egress_rif_cnt_p</td><td>- Egress Router Interface array num.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Sun Feb 22 2015 10:07:48 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
