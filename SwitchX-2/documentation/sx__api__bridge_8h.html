<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_bridge.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.9100</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_bridge.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__bridge_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a8335bd578d3a91f0346dfa9d1fa9b096">sx_api_bridge_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a9522f3f7337df4a6957c2026b2bd0cfd">sx_api_bridge_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a64a8f3e22c4d6a53b5432edfbfab4a1e">sx_api_bridge_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_bridge_id_t *bridge_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a7c1026fba3045a898ad1cc535dc9ccd7">sx_api_bridge_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_filter_t *filter_p, sx_bridge_id_t *bridge_id_list_p, uint32_t *bridge_id_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a2bd03f2e6cc04bafeca6ab89d91f905c">sx_api_bridge_port_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_port_log_id_t log_port, const sx_vlan_id_t vlan, const sx_untagged_member_state_t egress_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a9e40aa8ac09b2090d0bf14515e489f10">sx_api_bridge_port_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_bridge_port_t *bridge_port_list_p, uint32_t *bridge_port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#ab637b1b2d02c5c3807ff90e0dc0b7a26">sx_api_bridge_vport_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_port_log_id_t log_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a32abb8ce6eee61fba5bab2e286c01b46">sx_api_bridge_vport_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_port_log_id_t *bridge_vport_list_p, uint32_t *bridge_vport_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a6423c09af9b60ded6ba5f89e763bb109">sx_api_bridge_vport_multi_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t *bridge_id_list, const sx_port_log_id_t *log_port_list, uint32_t list_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a2f600518fa4f5d6c059ae146e64cfeca">sx_api_bridge_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_flow_counter_id_t flow_counter_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a2091d5b177d960b08d682df06e430d41">sx_api_bridge_counter_bind_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_flow_counter_id_t *flow_counter_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a527d1bfb48e9c09614952586b21f693a">sx_api_bridge_mirror_set</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, const sx_mirror_mode_t mirror_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a8368b2b6f15e81f9f7bdffbb68f750ad">sx_api_bridge_mirror_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, sx_mirror_mode_t *mirror_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a792aa5f36a6706e856cfb0e6749d4c9d">sx_api_bridge_tunnel_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#ae49baad20f4706d59a2a8700b32be549">sx_api_bridge_tunnel_counter_bind_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8335bd578d3a91f0346dfa9d1fa9b096"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_log_verbosity_level_set" ref="a8335bd578d3a91f0346dfa9d1fa9b096" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the log verbosity level of BRIDGE MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- BRIDGE module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- BRIDGE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a9522f3f7337df4a6957c2026b2bd0cfd"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_log_verbosity_level_get" ref="a9522f3f7337df4a6957c2026b2bd0cfd" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the log verbosity level of BRIDGE MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- BRIDGE module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- BRIDGE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a64a8f3e22c4d6a53b5432edfbfab4a1e"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_set" ref="a64a8f3e22c4d6a53b5432edfbfab4a1e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_bridge_id_t *bridge_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to create/destroy a bridge. This function is supported in 802.1D mode only. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_id_p</td><td>- a bridge_id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c1026fba3045a898ad1cc535dc9ccd7"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_iter_get" ref="a7c1026fba3045a898ad1cc535dc9ccd7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_filter_t *filter_p, sx_bridge_id_t *bridge_id_list_p, uint32_t *bridge_id_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bridge_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves a list of one or more Bridge IDs. This function is not supported in 802.1Q mode. The following use case scenarios apply with different input parameters X = don't-care</p>
<ul>
<li>1) cmd = SX_ACCESS_CMD_GET, bridge_id = X, bridge_id_list = X, bridge_id_cnt = 0: In this case the API will return the total number of bridge IDs in the internal DB.</li>
</ul>
<ul>
<li>2) cmd = SX_ACCESS_CMD_GET, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt = 1: In this case the API will check if the specified bridge_id exists. If it does, the bridge ID will be returned in the bridge_id_list along with a bridge_id_cnt of 1. If the bridge ID does not exist, an empty list will be returned with bridge_id_cnt = 0. A non-NULL bridge_id_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>3) cmd = SX_ACCESS_CMD_GET, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt &gt; 1: A bridge_id_cnt &gt; 1 will be treated as a bridge_id_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
</ul>
<ul>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, bridge_id = X, bridge_id_list = NULL, bridge_id_cnt = 0: A zero bridge_id_cnt and an empty bridge_id_list will be returned.</li>
</ul>
<ul>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, bridge_id = X, bridge_id_list = valid, bridge_id_cnt &gt; 0: In this case the API will return the first bridge_id_cnt bridge IDs starting from the head of the database. The total number of elements fetched will be returned as bridge_id_cnt. Note: returned bridge_id_cnt may be less than or equal to the requested bridge_id_cnt. The input bridge ID is ignored in this case. A non-NULL bridge_id_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt &gt; 0: In this case the API will return the next set of bridge IDs starting from the next bridge ID after the specified bridge ID. The total number of elements fetched will be returned as the bridge_id_cnt. Note: returned bridge_id_cnt may be less than or equal to the requested bridge_id_cnt. If no valid next bridge ID exists in the db, an empty list will be returned. A non-NULL bridge_id_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_id_list_p</td><td>- return list of bridge IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bridge_id_cnt_p</td><td>- [in] number of bridge IDs to get</p>
<ul>
<li>[out] number of bridge IDs returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a2bd03f2e6cc04bafeca6ab89d91f905c"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_port_set" ref="a2bd03f2e6cc04bafeca6ab89d91f905c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_port_log_id_t log_port, const sx_vlan_id_t vlan, const sx_untagged_member_state_t egress_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_id_t&#160;</td>
          <td class="paramname"><em>vlan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_untagged_member_state_t&#160;</td>
          <td class="paramname"><em>egress_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: switchX2 This function is used to add a port and vlan to a bridge. When multiple vlan bridge support is enabled, it is possible to bind different vlans to the same bridge. When multiple vlan bridge support is disabled, you can bind only one vlan to each bridge. When cmd==DELETE_PORT the log_port will be removed from all associated bridges. This function is supported in 802.1D mode only. Supported devices: SwitchX, SwitchX2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_PORT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan</td><td>- vlan_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_mode</td><td>- TAGGED/UNTAGGED. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e40aa8ac09b2090d0bf14515e489f10"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_port_get" ref="a9e40aa8ac09b2090d0bf14515e489f10" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_bridge_port_t *bridge_port_list_p, uint32_t *bridge_port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_port_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bridge_port_t *&#160;</td>
          <td class="paramname"><em>bridge_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bridge_port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: switchX2 This function is used to get a list of all ports and vlans associated with a bridge. When using bridge_port_cnt_p == 0, the number of existing entries will be returned. This function is supported in 802.1D mode only. Supported devices: SwitchX, SwitchX2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_port_list_p</td><td>log_port - a pointer to a bridge_port list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>bridge_port_cnt_p - size of the bridge_port_list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab637b1b2d02c5c3807ff90e0dc0b7a26"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_vport_set" ref="ab637b1b2d02c5c3807ff90e0dc0b7a26" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_port_log_id_t log_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function is used to add a virtual port to a bridge.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical virtual port ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a32abb8ce6eee61fba5bab2e286c01b46"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_vport_get" ref="a32abb8ce6eee61fba5bab2e286c01b46" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_port_log_id_t *bridge_vport_list_p, uint32_t *bridge_vport_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>bridge_vport_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bridge_vport_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function is used to get a list of all virtual ports associated with a bridge. When using bridge_vport_cnt_p == 0, the number of existing entries will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_vport_list_p</td><td>- a pointer to a sx_port_log_id_t list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>bridge_vport_cnt_p - size of the bridge_vport_list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a6423c09af9b60ded6ba5f89e763bb109"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_vport_multi_set" ref="a6423c09af9b60ded6ba5f89e763bb109" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t *bridge_id_list, const sx_port_log_id_t *log_port_list, uint32_t list_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_multi_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>list_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function is used to add/del a virtual ports from list to corresponding bridge from list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id_list</td><td>- bridge_id list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list</td><td>- logical virtual port ID list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_cnt</td><td>- list counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a2f600518fa4f5d6c059ae146e64cfeca"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_counter_bind_set" ref="a2f600518fa4f5d6c059ae146e64cfeca" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_flow_counter_id_t flow_counter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>flow_counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function is used to bind/unbind a flow counter to a bridge.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flow_counter_id</td><td>- flow counter id to bind</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a2091d5b177d960b08d682df06e430d41"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_counter_bind_get" ref="a2091d5b177d960b08d682df06e430d41" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_flow_counter_id_t *flow_counter_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>flow_counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function is used to get the flow counter bound to the bridge. When no counter is bound to the bridge, flow_counter_id_p will be set to SX_FLOW_COUNTER_ID_INVALID.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_counter_id_p</td><td>- bound counter id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a527d1bfb48e9c09614952586b21f693a"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_mirror_set" ref="a527d1bfb48e9c09614952586b21f693a" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, const sx_mirror_mode_t mirror_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_mirror_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_mode_t&#160;</td>
          <td class="paramname"><em>mirror_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function sets the mirroring mode for a bridge. Currently only ingress direction is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- mirror bridge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_mode</td><td>- enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a8368b2b6f15e81f9f7bdffbb68f750ad"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_mirror_get" ref="a8368b2b6f15e81f9f7bdffbb68f750ad" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, sx_mirror_mode_t *mirror_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_mirror_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mirror_mode_t *&#160;</td>
          <td class="paramname"><em>mirror_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function gets the mirroring mode for a bridge by direction and bridge ID Currently only ingress direction is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- mirror bridge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress/egress </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mirror_mode_p</td><td>- the returned mirroring mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="a792aa5f36a6706e856cfb0e6749d4c9d"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_tunnel_counter_bind_set" ref="a792aa5f36a6706e856cfb0e6749d4c9d" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, const sx_flow_counter_id_t counter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_tunnel_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_tunnel_counter_attr_t *&#160;</td>
          <td class="paramname"><em>counter_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API bind counter for tunnel mapped to the bridge Supported devices: Spectrum</p>
<p>For ENCAP_UC and ENCAP_MC counters this operation can be performed only when FDB doesn't contain any entries for tunnel in fid counters can be bind only if mapping bridge to tunnel is configured</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_BIND/SX_ACCESS_CMD_UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id on which tunnel mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- counter attributes (type, tunnel_id) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_d</td><td>- flow counter ID which will be bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel or tunnel mapping do not exist. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if counter already bound. </dd></dl>

</div>
</div>
<a class="anchor" id="ae49baad20f4706d59a2a8700b32be549"></a><!-- doxytag: member="sx_api_bridge.h::sx_api_bridge_tunnel_counter_bind_get" ref="ae49baad20f4706d59a2a8700b32be549" args="(const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, sx_flow_counter_id_t *counter_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_tunnel_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_tunnel_counter_attr_t *&#160;</td>
          <td class="paramname"><em>counter_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API get flow counter for tunnel mapped to the bridge Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id on which tunnel mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- counter attributes (type, tunnel_id) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- pointer to flow counter ID. Returns bound counter_id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel isn't exists or mapping is not found. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter isn't bound. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Mon Oct 15 2018 23:24:30 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
