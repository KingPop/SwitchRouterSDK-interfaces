<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_host_ifc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.6000</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_host_ifc.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__host__ifc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#ae1bbebd5bde7a2e3ecccf74841fff356">POSIX_EINTR_RETRY</a>(ret_value, op)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a29f2c0d0f82dc50c9c4fed61d616ed05">sx_api_host_ifc_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a2d2edad2c47118707a354cfdc7e7cc8c">sx_api_host_ifc_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a637791e768092ab8a145295720b3ad37">sx_api_host_ifc_open</a> (const sx_api_handle_t handle, sx_fd_t *fd_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#ac026593fdc09d0ba312cfed674f532f1">sx_api_host_ifc_close</a> (const sx_api_handle_t handle, sx_fd_t *fd_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#aa47a742e8238beb3d92fa584bbc5d90d">sx_api_host_ifc_trap_group_set</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_trap_group_t trap_group, const sx_trap_group_attributes_t *trap_group_attributes_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#aa9f1f7b2a2e99c7a8042321f3914fa25">sx_api_host_ifc_trap_group_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_trap_group_t trap_group, sx_trap_group_attributes_t *trap_group_attributes_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a1b311526a58fe66b893bf2d1e8b0a9d4">sx_api_host_ifc_trap_group_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_trap_group_t trap_group_id, const sx_trap_group_filter_t *filter_p, sx_trap_group_t *trap_group_id_list_p, uint32_t *trap_group_id_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a3b99edc2800fa0eb9f5da2084f34673f">sx_api_host_ifc_trap_id_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_trap_group_t trap_group, const sx_trap_action_t trap_action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a617dd77f8834dce0d5adf40b9dd7ff1b">sx_api_host_ifc_user_defined_trap_id_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, sx_trap_id_user_defined_attributes_t *trap_attributes_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a41ba1d6d892efdba33bd88b786846a1c">sx_api_host_ifc_trap_id_register_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_user_channel_t *user_channel_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a4a3a7ff331d172313bc767e485edf8ac">sx_api_host_ifc_trap_id_register_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_user_channel_t *user_channel, sx_user_channel_t *user_channel_list_p, uint32_t *user_channel_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a66141735e7f680e87c489c9d4a3a0e8c">sx_api_host_ifc_port_vlan_trap_id_register_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_host_ifc_register_key_t *register_key_p, const sx_user_channel_t *user_channel_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a0216e0c5475dce069d1f4e07de08c2dd">sx_api_host_ifc_port_vlan_trap_id_register_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_host_ifc_register_get_entry_t *register_entry, sx_host_ifc_register_get_entry_t *register_entry_list_p, uint32_t *register_entry_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a37821970ee589f06824d4bd6fe43f876">sx_api_host_ifc_trap_filter_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a71a470cc13dc9bf1fd919d2c81a75772">sx_api_host_ifc_trap_filter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_port_log_id_t log_port_id, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#ad7da4f1d811ab525751470302e4e96ea">sx_api_host_ifc_policer_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_group_t trap_group, const sx_policer_id_t policer_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#ac40d153892ede32db36bc79f0ce80c14">sx_api_host_ifc_policer_bind_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_trap_group_t trap_group, sx_policer_id_t *policer_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__host__ifc_8h.html#a9de7c875854a65fc5bb8c5dd12c5aad7">sx_api_host_ifc_counters_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_host_ifc_counters_filter_t *filter_p, sx_host_ifc_counters_t *host_ifc_cnt_p)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ae1bbebd5bde7a2e3ecccf74841fff356"></a><!-- doxytag: member="sx_api_host_ifc.h::POSIX_EINTR_RETRY" ref="ae1bbebd5bde7a2e3ecccf74841fff356" args="(ret_value, op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POSIX_EINTR_RETRY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                 \
        ret_value = op;                  \
    } <span class="keywordflow">while</span> (((ret_value) == -1) &amp;&amp; (errno == EINTR))
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a29f2c0d0f82dc50c9c4fed61d616ed05"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_log_verbosity_level_set" ref="a29f2c0d0f82dc50c9c4fed61d616ed05" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the log verbosity level of HOST INTERFACE MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- HOST INTERFACE module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- HOST INTERFACE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a2d2edad2c47118707a354cfdc7e7cc8c"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_log_verbosity_level_get" ref="a2d2edad2c47118707a354cfdc7e7cc8c" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the log verbosity level of HOST INTERFACE MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- HOST INTERFACE module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- HOST INTERFACE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a637791e768092ab8a145295720b3ad37"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_open" ref="a637791e768092ab8a145295720b3ad37" args="(const sx_api_handle_t handle, sx_fd_t *fd_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_open </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fd_t *&#160;</td>
          <td class="paramname"><em>fd_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the file descriptor of the current open channel used for receiving a packet Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fd_p</td><td>- file descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO error closing channel to the sx driver </dd></dl>

</div>
</div>
<a class="anchor" id="ac026593fdc09d0ba312cfed674f532f1"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_close" ref="ac026593fdc09d0ba312cfed674f532f1" args="(const sx_api_handle_t handle, sx_fd_t *fd_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_close </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fd_t *&#160;</td>
          <td class="paramname"><em>fd_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function closes the file descriptor of the current open channel used for receiving a packet Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd_p</td><td>- file descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO error closing channel to the sx driver </dd></dl>

</div>
</div>
<a class="anchor" id="aa47a742e8238beb3d92fa584bbc5d90d"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_group_set" ref="aa47a742e8238beb3d92fa584bbc5d90d" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_trap_group_t trap_group, const sx_trap_group_attributes_t *trap_group_attributes_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_attributes_t *&#160;</td>
          <td class="paramname"><em>trap_group_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create / Edit a trap group Allows creating a new trap group with certain attributes, and editing an existing trap group with new attributes. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group</td><td>- The trap group, must be between 0-63. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group_attributes_p</td><td>- Trap group attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f1f7b2a2e99c7a8042321f3914fa25"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_group_get" ref="aa9f1f7b2a2e99c7a8042321f3914fa25" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_trap_group_t trap_group, sx_trap_group_attributes_t *trap_group_attributes_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_trap_group_attributes_t *&#160;</td>
          <td class="paramname"><em>trap_group_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get Trap group attributes: Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group</td><td>- The trap group, must be between 0-63. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trap_group_attributes_p</td><td>- Trap group attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened </dd></dl>

</div>
</div>
<a class="anchor" id="a1b311526a58fe66b893bf2d1e8b0a9d4"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_group_iter_get" ref="a1b311526a58fe66b893bf2d1e8b0a9d4" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_trap_group_t trap_group_id, const sx_trap_group_filter_t *filter_p, sx_trap_group_t *trap_group_id_list_p, uint32_t *trap_group_id_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_group_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_trap_group_t *&#160;</td>
          <td class="paramname"><em>trap_group_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>trap_group_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves a list of one or more trap group IDs. The following use case scenarios apply with different input parameters X = don't-care</p>
<ul>
<li>1) cmd = SX_ACCESS_CMD_GET, swid = valid, trap_group_id = X, trap_group_id_list = X, trap_group_id_cnt = 0: In this case the API will return the total number of trap group IDs in the internal DB.</li>
</ul>
<ul>
<li>2) cmd = SX_ACCESS_CMD_GET, swid = valid, trap_group_id = valid/invalid, trap_group_id_list = valid, trap_group_id_cnt = 1: In this case the API will check if the specified trap_group_id exists. If it does, the trap group ID will be returned in the trap_group_id_list along with a trap_group_id_cnt of 1. If the trap group ID does not exist, an empty list will be returned with trap_group_id_cnt = 0. A non-NULL trap_group_id_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>3) cmd = SX_ACCESS_CMD_GET, swid = vaild, trap_group_id = valid/invalid, trap_group_id_list = valid, trap_group_id_cnt &gt; 1: A trap_group_id_cnt &gt; 1 will be treated as a trap_group_id_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
</ul>
<ul>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, swid = X, trap_group_id = X, trap_group_id_list = NULL, trap_group_id_cnt = 0: A zero trap_group_id_cnt and an empty trap_group_id_list will be returned.</li>
</ul>
<ul>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, swid = valid, trap_group_id = X, trap_group_id_list = valid, trap_group_id_cnt &gt; 0: In this case the API will return the first trap_group_id_cnt trap group IDs starting from the head of the database. The total number of elements fetched will be returned as trap_group_id_cnt. Note: returned trap_group_id_cnt may be less than or equal to the requested trap_group_id_cnt. The input trap group ID is ignored in this case. A non-NULL trap_group_id_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, swid = valid, trap_group_id = valid/invalid, trap_group_id_list = valid, trap_group_id_cnt &gt; 0: In this case the API will return the next set of trap group IDs starting from the next trap group ID after the specified trap group ID. The total number of elements fetched will be returned as the trap_group_id_cnt. Note: returned trap_group_id_cnt may be less than or equal to the requested trap_group_id_cnt. If no valid next trap group ID exists in the db, an empty list will be returned. A non-NULL trap_group_id_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group_id</td><td>- trap group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trap_group_id_list_p</td><td>- return list of trap group IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trap_group_id_cnt_p</td><td>- [in] number of trap group IDs to get</p>
<ul>
<li>[out] number of trap group IDs returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3b99edc2800fa0eb9f5da2084f34673f"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_id_set" ref="a3b99edc2800fa0eb9f5da2084f34673f" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_trap_group_t trap_group, const sx_trap_action_t trap_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_id_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_action_t&#160;</td>
          <td class="paramname"><em>trap_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure traps / event properties for each device in the system: Map Trap ID / Event ID to 1 of the 3 Priority groups: HIGH, MEDIUM, LOW. Configure trap action (for traps only) Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group</td><td>- Trap group handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_action</td><td>- Trap action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened</dd></dl>
<p>Note: when configuring trap_id of SX_TRAP_ID_ETH_L2_PACKET_SAMPLING /SX_TRAP_ID_GENERAL_FDB /SX_TRAP_ID_ACL/SX_TRAP_ID_IPTRAP, trap_action field is ignored. Instead, the action should be configured in each module. </p>

</div>
</div>
<a class="anchor" id="a617dd77f8834dce0d5adf40b9dd7ff1b"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_user_defined_trap_id_set" ref="a617dd77f8834dce0d5adf40b9dd7ff1b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, sx_trap_id_user_defined_attributes_t *trap_attributes_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_user_defined_trap_id_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_trap_id_user_defined_attributes_t *&#160;</td>
          <td class="paramname"><em>trap_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API adds/deletes user defined trap ID's. The trap ID created should be in the [SX_TRAP_ID_USER_BASE,SX_TRAP_ID_USER_MAX] range. For cmd == SX_ACCESS_CMD_DELETE, trap_attributes_p can be NULL. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_attributes_p</td><td>- Traps attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS If trap ID is already configured. </dd></dl>

</div>
</div>
<a class="anchor" id="a41ba1d6d892efdba33bd88b786846a1c"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_id_register_set" ref="a41ba1d6d892efdba33bd88b786846a1c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_user_channel_t *user_channel_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_id_register_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_user_channel_t *&#160;</td>
          <td class="paramname"><em>user_channel_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register / DeRegister Traps (STP , LACP) or Events (Port up / down , Temperature event) in the driver. Configure the driver to pass packets matching this trap ID / Event ID, criteria &amp; SWID to the client (according to user_channel). The source_log_port parameter of the received L2 trap always relates to the relevant physical port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- REGISTER - register to trap trap_id DEREGISTER - de-register to trap trap_id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_channel_p</td><td>- The channel for the packets to be trapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened </dd></dl>

</div>
</div>
<a class="anchor" id="a4a3a7ff331d172313bc767e485edf8ac"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_id_register_get" ref="a4a3a7ff331d172313bc767e485edf8ac" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_user_channel_t *user_channel, sx_user_channel_t *user_channel_list_p, uint32_t *user_channel_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_id_register_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_user_channel_t *&#160;</td>
          <td class="paramname"><em>user_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_user_channel_t *&#160;</td>
          <td class="paramname"><em>user_channel_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>user_channel_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function get the trap's user channel list according to the swid and trap_id. The following use case scenarios apply with different input parameters. 1) SX_ACCESS_CMD_GET When *user_channel_cnt_p is not 0, this function returns a list of user channels. The returned user_channel_cnt may be less or equal to the requested user_channel_cnt. When *user_channel_cnt_p is 0, this function returns the total number of user channels configured for the specified trap ID. The input user_channel is ignored in this case.</p>
<p>2) SX_ACCESS_CMD_GET_FIRST In this case the API will return the first set of user channels. The returned user_channel_cnt may be less or equal to the requested user_channel_cnt. The input user_channel is ignored int this case.</p>
<p>3) SX_ACCESS_CMD_GETNEXT In this case the API will return the next set of user channels starting from the next user channel after the specified user channel. The returned user_channel_cnt may be less or equal to the requested user_channel_cnt. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_channel</td><td>- User channel, as a key to get next entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_channel_list_p</td><td>- List of user channels. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user_channel_cnt_p</td><td>- as input: number of user channels requested. as output: number of user channels returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a66141735e7f680e87c489c9d4a3a0e8c"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_port_vlan_trap_id_register_set" ref="a66141735e7f680e87c489c9d4a3a0e8c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_host_ifc_register_key_t *register_key_p, const sx_user_channel_t *user_channel_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_port_vlan_trap_id_register_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_host_ifc_register_key_t *&#160;</td>
          <td class="paramname"><em>register_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_user_channel_t *&#160;</td>
          <td class="paramname"><em>user_channel_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register / DeRegister Traps (STP , LACP) or Events (Port up / down , Temperature event) in the driver. Configure the driver to pass packets matching this trap ID / Event ID, port OR vlan &amp; SWID to the client (according to user_channel). The source_log_port parameter of the received L2 trap always relates to the relevant physical port. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- REGISTER - register to trap trap_id DEREGISTER - de-register to trap trap_id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_key_p</td><td>- Port/FID/Global </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_channel_p</td><td>- The channel for the packets to be trapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened </dd></dl>

</div>
</div>
<a class="anchor" id="a0216e0c5475dce069d1f4e07de08c2dd"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_port_vlan_trap_id_register_get" ref="a0216e0c5475dce069d1f4e07de08c2dd" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_host_ifc_register_get_entry_t *register_entry, sx_host_ifc_register_get_entry_t *register_entry_list_p, uint32_t *register_entry_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_port_vlan_trap_id_register_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_host_ifc_register_get_entry_t *&#160;</td>
          <td class="paramname"><em>register_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_host_ifc_register_get_entry_t *&#160;</td>
          <td class="paramname"><em>register_entry_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>register_entry_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function get the trap's register entry (register key and user channel) list according to the swid and trap_id. The following use case scenarios apply with different input parameters. 1) SX_ACCESS_CMD_GET When *register_entry_cnt_p is not 0, this function returns a list of register entries. The returned register_entry_cnt_p may be less or equal to the requested register_entry_cnt_p. When *register_entry_cnt_p is 0, this function returns the total number of register entries configured for the specified trap ID. The input register entry is ignored in this case.</p>
<p>2) SX_ACCESS_CMD_GET_FIRST In this case the API will return the first set of register entries. The returned register_entry_cnt may be less or equal to the requested register_entry_cnt. The input register entry is ignored int this case.</p>
<p>3) SX_ACCESS_CMD_GETNEXT In this case the API will return the next set of register entries starting from the next register entry after the specified register entry. The returned register_entry_cnt may be less or equal to the requested register_entry_cnt. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">register_entry</td><td>- Register entry, as a key to get next entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">register_entry_list_p</td><td>- List of register entries. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">register_entry_cnt_p</td><td>- as input: number of register entries requested. as output: number of register entries returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a37821970ee589f06824d4bd6fe43f876"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_filter_set" ref="a37821970ee589f06824d4bd6fe43f876" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_filter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>log_port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function configures the switch to filter packets received from certain ports/LAGs. If cmd is ADD, the given ports are added to the filter list. If the cmd is DELETE the given ports are removed from the trap filter list. If the cmd is DELETE_ALL all ports and LAGs which were previously added to the filter are removed. In this case log_port_num and log_port_list parameters are ignored. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / DELETE /DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID to filter on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_port_list</td><td>- List of Logical Ports to ADD/DELETE to/from the trap's filter list. If the API returns an error the list will contain the ports/LAGs which were not added successfully to the filter list. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_port_num</td><td>- Number of Logical Ports to ADD/DELETE to/from the trap's filter list. If the API returns and error it will hold the number of ports/LAGs which were not added successfully to the filter list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the command is not supported </dd>
<dd>
SX_STATUS_ERROR if a general error has occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a71a470cc13dc9bf1fd919d2c81a75772"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_trap_filter_get" ref="a71a470cc13dc9bf1fd919d2c81a75772" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_id_t trap_id, const sx_port_log_id_t log_port_id, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_trap_filter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_id_t&#160;</td>
          <td class="paramname"><em>trap_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>log_port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function get the trap's filter list according to the swid and trap_id. The following use case scenarios apply with different input parameters. 1) SX_ACCESS_CMD_GET When *log_port_cnt_p is not 0, this function returns a list of logical port IDs. The returned log_port_cnt may be less or equal to the requested log_port_cnt. When *log_port_cnt_p is 0, this function returns the the total number of ports/LAGs configured for the specified trap ID. The input log_port_id is ignored in this case.</p>
<p>2) SX_ACCESS_CMD_GET_FIRST In this case the API will return the first set of logical port IDs. The returned log_port_cnt may be less or equal to the requested log_port_cnt. The input log_port_id is ignored int this case.</p>
<p>3) SX_ACCESS_CMD_GETNEXT In this case the API will return the next set of logical port IDs starting from the next logical port ID after the specified logical port ID. The returned log_port_cnt may be less or equal to the requested log_port_cnt.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_id</td><td>- Trap ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_id</td><td>- Logical port ID, as a key to get next entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list</td><td>- List of logical ports. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_port_num</td><td>- as input: number of logical ports requested. as output: number of logical ports returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR if a general error has occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ad7da4f1d811ab525751470302e4e96ea"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_policer_bind_set" ref="ad7da4f1d811ab525751470302e4e96ea" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_trap_group_t trap_group, const sx_policer_id_t policer_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_policer_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_policer_id_t&#160;</td>
          <td class="paramname"><em>policer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function binds/unbinds a policer to a trap priority. The policer type must be a global slow policer. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group</td><td>- Trap group . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policer_id</td><td>- Policer ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_MEMORY_ERROR error handling memory </dd>
<dd>
SX_STATUS_NO_RESOURCES device was not opened </dd></dl>

</div>
</div>
<a class="anchor" id="ac40d153892ede32db36bc79f0ce80c14"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_policer_bind_get" ref="ac40d153892ede32db36bc79f0ce80c14" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_trap_group_t trap_group, sx_policer_id_t *policer_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_policer_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_trap_group_t&#160;</td>
          <td class="paramname"><em>trap_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_policer_id_t *&#160;</td>
          <td class="paramname"><em>policer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get policer ID per trap group: Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap_group</td><td>- The trap group, must be between 0-63. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">policer_id</td><td>- Policer ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if no policer is bound to trap_group </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a9de7c875854a65fc5bb8c5dd12c5aad7"></a><!-- doxytag: member="sx_api_host_ifc.h::sx_api_host_ifc_counters_get" ref="a9de7c875854a65fc5bb8c5dd12c5aad7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_host_ifc_counters_filter_t *filter_p, sx_host_ifc_counters_t *host_ifc_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_host_ifc_counters_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_host_ifc_counters_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_host_ifc_counters_t *&#160;</td>
          <td class="paramname"><em>host_ifc_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get host interface counters: Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- Filter to determine which counters to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">host_ifc_cnt_p</td><td>- Host interface counters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameters is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Wed Aug 30 2017 17:07:50 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
