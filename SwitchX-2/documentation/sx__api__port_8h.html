<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_port.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.7004</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_port.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__port_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ac3457a41837c6780bbf94b56dd2a0cd4">sx_api_port_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#aeacb0e86f68ff55169aaf669657a22a1">sx_api_port_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a320b05e1b217964e13862e3e20c48b22">sx_api_port_device_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_device_id_t device_id, const sx_mac_addr_t *base_mac_addr_p, sx_port_attributes_t *port_attributes_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af2183e8bd9f2b4301c20dbc281152eb7">sx_api_port_device_get</a> (const sx_api_handle_t handle, const sx_device_id_t device_id, const sx_swid_t swid, sx_port_attributes_t *port_attributes_list_p, uint32_t *port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#aa2e0b743cdbcbe49a4486ae074352c62">sx_api_port_device_base_mac_get</a> (const sx_api_handle_t handle, const sx_device_id_t device_id, sx_mac_addr_t *base_mac_addr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ad6b5cce473414e8dd0cccff99f607937">sx_api_port_mapping_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t *log_port_list_p, const sx_port_mapping_t *port_mapping_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ab6aac3d1a251bebecea8661d892ae138">sx_api_port_mapping_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t *log_port_list_p, sx_port_mapping_t *port_mapping_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a8547e671b86adfa81b8914bc6d4a7c9a">sx_api_port_device_list_get</a> (const sx_api_handle_t handle, sx_device_info_t *device_info_list_p, uint32_t *device_info_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a5ac4e100b0a7e63857956f85f7564371">sx_api_port_swid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ae9f581acd6ea7e53fa000614c679a3a2">sx_api_port_swid_list_get</a> (const sx_api_handle_t handle, sx_swid_t *swid_list_p, uint32_t *swid_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a18e894e7fd6e658b8f268fefca4fd29b">sx_api_port_swid_bind_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a0b4fbd51ebc7bce4001fd347dd1128e3">sx_api_port_swid_bind_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_swid_t *swid_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ad157db98602e015414c58572fb807ce6">sx_api_port_swid_port_list_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a76a1283579d3589c1282db08adf9c15f">sx_api_port_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_mode_t mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a8915383346dfe6d396c27c2f4b02bb61">sx_api_port_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_mode_t *mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a177cc12ea300d6609cfce0d2affecbb7">sx_api_port_mtu_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_mtu_t mtu_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a30b32059620165e64aea03eeb674ffc0">sx_api_port_mtu_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_mtu_t *max_mtu_size_p, sx_port_mtu_t *oper_mtu_size_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a1eb11c6043ef0aaf7941b424c00bb2e9">sx_api_port_speed_admin_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_speed_capability_t *admin_speed_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a9903aa3a1fec695b1df5a1afd9cce1fb">sx_api_port_speed_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_speed_capability_t *admin_speed_p, sx_port_oper_speed_t *oper_speed_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ac06ca456bb66a95dbd43b418f4455ce9">sx_api_port_capability_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_capability_t *capability_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a02d492ab4853f76e8eb11bbe2178cd6f">sx_api_port_fec_capability_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_fec_capability_t *fec_capability_list_p, uint32_t *fec_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af760dc1277fa07b46d3daa8ac75b5cd7">sx_api_port_phys_addr_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_mac_addr_t *port_mac_addr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ae61ba2b35c7d6d649fdf09ca10e4a613">sx_api_port_phys_addr_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_mac_addr_t *port_mac_addr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a9c41fd0d58d3a1a376b19ea50e21a87d">sx_api_port_phys_loopback_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phys_loopback_t phys_loopback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#acfda04376fd15f844335a23d60e84cba">sx_api_port_phys_loopback_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_phys_loopback_t *phys_loopback_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a086e428d40ce1a614e1684f7c1155875">sx_api_port_state_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_admin_state_t admin_state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a538e5c6c74a875f9f6a29af53b40f6e7">sx_api_port_state_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_oper_state_t *oper_state_p, sx_port_admin_state_t *admin_state_p, sx_port_module_state_t *module_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a242ad744d414037daa392640ac9ad43f">sx_api_port_global_fc_enable_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_mode_t fc_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a98768602683d64f5763f8db6964d6612">sx_api_port_global_fc_enable_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_flow_ctrl_mode_t *fc_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ace8cc503f4eb1d6aa23489ccdcd5fd1e">sx_api_port_pfc_enable_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_prio_t pfc_prio, const sx_port_flow_ctrl_mode_t fc_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a3a59090e625968bd111b29356454a66f">sx_api_port_pfc_enable_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_prio_t pfc_prio, sx_port_flow_ctrl_mode_t *fc_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ab1da148241d2e8b5a7c3061995926d5d">sx_api_port_counter_ieee_802_dot_3_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_ieee_802_dot_3_t *cntr_ieee_802_dot_3_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a3164c4dd6434ee771f6b2e38020bf82c">sx_api_port_counter_rfc_2863_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_2863_t *cntr_rfc_2863_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ac4d9e0a2e66d1fde42fce0c0ce24e3bb">sx_api_port_counter_rfc_2819_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_2819_t *cntr_rfc_2819_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af164c75be838e07f152274206ce2b346">sx_api_port_counter_rfc_3635_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_3635_t *cntr_rfc_3635_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a20cb565fd4a0ebd4916f36ecf7125dec">sx_api_port_counter_cli_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_cli_t *cntr_cli_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a508d4c802af65d7ca579e82f74a97cf2">sx_api_port_counter_prio_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_cos_ieee_prio_t prio_id, sx_port_cntr_prio_t *cntr_prio_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a48f6e4fc57d5892dba61185154c66446">sx_api_port_counter_tc_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_tc_id_t tc_id, sx_port_traffic_cntr_t *cntr_tc_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#aa0e6a9a3d90145c303b61bca3541c0c1">sx_api_port_counter_buff_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_cos_priority_group_t buff_id, sx_port_cntr_buff_t *cntr_buff_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#aa5328e02b80e20924b025b3142ca546e">sx_api_port_counter_perf_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_prio_id_t prio_id, sx_port_cntr_perf_t *cntr_perf_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a5ea8fac313cd4a57dae8547c4fe676d7">sx_api_port_counter_discard_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_discard_t *cntr_discard_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a4b793ce2927cd10dee9fd39d0acf1e71">sx_api_port_counter_clear_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t all_ports, const sx_port_cntr_grp_t cntr_grp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a64f3ed15b0f87c0f5791f4b777aa61e8">sx_api_port_counter_phy_layer_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_phy_layer_t *cntr_phy_layer_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a239e0e4d8fcc7da1525bd29dfc7dda48">sx_api_port_init_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af4dbc06a2e2f50266cf07b01dae622a8">sx_api_port_deinit_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a78b976296aff6d5caec1ca9ec085d632">sx_api_port_storm_control_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, const sx_port_storm_control_params_t *storm_control_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af0fd4ac374492bba4dce7fd46ae1d5fd">sx_api_port_storm_control_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, sx_port_storm_control_params_t *storm_control_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ab910ad0aeebae07d21c5e686febec8cb">sx_api_port_storm_control_counters_clear_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, const sx_policer_counters_clear_t *clear_counters_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a50faf7675404b7b50880be9e94b0c638">sx_api_port_storm_control_counters_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, sx_policer_counters_t *policer_counters_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#abfca95b7b61f32a766a334b72477890e">sx_api_port_sflow_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_sflow_params_t *sflow_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a00b0a4e788461ae6bb1f20487adeadb6">sx_api_port_sflow_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_sflow_params_t *sflow_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a258fa9e727c49b6bd37475942929ed0f">sx_api_port_sflow_statistics_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_sflow_statistics_t *sflow_stat_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a47405313af00dc31c45b8bb570de9229">sx_api_port_loopback_filter_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_loopback_filter_mode_t lbf_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a156c5a50373b95c67fc62207cc368129">sx_api_port_loopback_filter_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_loopback_filter_mode_t *lbf_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#acab75e1ae238f36f3ac6c8c038c77c34">sx_api_port_isolate_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_log_id_t *log_port_list_p, const uint32_t log_port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a44340edabf4a592c7b20760837532f3d">sx_api_port_isolate_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ad40cb2f24f0db8d65dec6e1020c814e3">sx_api_port_swid_type_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_swid_type_t *swid_type_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a993301f3abf5d96ab7c5d638ea0a82fe">sx_api_port_vport_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_vlan_id_t vlan_id, sx_port_log_id_t *log_vport_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#abd0cfb324bd833a5e28129c67784da9e">sx_api_port_vport_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vlan_id_t *vlan_id_list_p, uint32_t *vport_vlan_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#afced2a9643b69573d9fd4420bad1d3ad">sx_api_port_vport_base_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t vport, sx_vlan_id_t *vlan_id_p, sx_port_log_id_t *log_port_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ae4b08efe8e636733ebce2910ea3f14ef">sx_api_port_vport_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t virtual_port, const sx_flow_counter_id_t flow_counter_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a53a335bd4164f0d7b0ec3dd5ef0b4e86">sx_api_port_vport_counter_bind_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, sx_flow_counter_id_t *flow_counter_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a6e385909330b1a91c195bdfcfccf2ce5">sx_api_port_vport_mirror_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, const sx_mirror_direction_t mirror_direction, const sx_mirror_mode_t mirror_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#afb429aafa04ed85e5067e1c260330cf8">sx_api_port_vport_mirror_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, const sx_mirror_direction_t mirror_direction, sx_mirror_mode_t *mirror_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ae7497db77430915b70638c5643044a66">sx_api_port_phy_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phy_speed_t speed, const sx_port_phy_mode_t admin_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#af025d901dace3b52c1c96874cdb54250">sx_api_port_phy_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phy_speed_t speed, sx_port_phy_mode_t *admin_mode_p, sx_port_phy_mode_t *oper_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a8d7eba93b6d86d73d3f15c6a070d9ee6">sx_api_port_discard_reason_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_port_discard_reason_t *discard_reason_list_p, const uint32_t list_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#afd76c376d228a7132221481c9ac2c52d">sx_api_port_forwarding_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_forwarding_mode_t admin_fwd_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a6faebd4529a3119a93941b51ff63213c">sx_api_port_forwarding_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_forwarding_mode_t *admin_fwd_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a994472bd0de2e3bbd71a4090a7fb853a">sx_api_port_parsing_depth_set</a> (const sx_api_handle_t handle, const uint16_t parsing_depth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a7787e441d72b3923373592cedfa66b8f">sx_api_port_parsing_depth_get</a> (const sx_api_handle_t handle, uint16_t *parsing_depth_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ad81cab6adb1ff0e9e00da8b71a9c0dc7">sx_api_port_vlan_ethertype_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_vlan_ethertype_t *ether_types_list_p, uint32_t ether_type_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a9e2c1c1165721f2dd979baaad7aa06c8">sx_api_port_vlan_ethertype_get</a> (const sx_api_handle_t handle, sx_vlan_ethertype_t *ether_types_list_p, uint32_t *ether_type_count_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a5cde445f80ba07b374ec43d429258213">sx_api_port_ber_threshold_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_fec_profile_e fec_profile, const sx_port_ber_fec_profile_threshold_data_t threshold_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a8f667dd7b660b94b62792c1ae69e5fce">sx_api_port_ber_threshold_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_fec_profile_e fec_profile, sx_port_ber_fec_profile_threshold_data_t *threshold_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a1b8fe894b0b098f71d6dc7377857f704">sx_api_port_ber_monitor_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_monitor_data_t monitor_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a24be4d40087906caa89dd9da0c42bec1">sx_api_port_ber_monitor_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_ber_monitor_data_t *monitor_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a90aed399a13799019672e507f020e62e">sx_api_port_ber_monitor_operational_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_ber_monitor_oper_data_t *monitor_oper_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a4862f48efbaf9707fe354b1f5b42f2f8">sx_api_port_sll_set</a> (const sx_api_handle_t handle, const uint64_t sll_max_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a47cddb263aaa3520ba641e528f138acc">sx_api_port_sll_get</a> (const sx_api_handle_t handle, uint64_t *sll_max_time_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#afd7e583a74d6398fbb03edf451688d1c">sx_api_port_hll_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const uint32_t hll_max_time, const uint32_t hll_stall_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#acb57f0fe402abeb9d42d47ac6a575762">sx_api_port_hll_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *hll_max_time_p, uint32_t *hll_stall_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#ac3aec8abde92ea8e8d6fa29b3a598b93">sx_api_port_crc_params_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_crc_params_t *crc_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a334fed1bc4eeccb5066c6c68fa56016f">sx_api_port_crc_params_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_crc_params_t *crc_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#a52a7bc5480bebf78a68b16cfa7338f9d">sx_api_port_ptp_params_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_ptp_params_t *port_ptp_params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__port_8h.html#aeeaf90f48d243537a9ace172db9c818f">sx_api_port_ptp_params_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_ptp_params_t *port_ptp_params_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac3457a41837c6780bbf94b56dd2a0cd4"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_log_verbosity_level_set" ref="ac3457a41837c6780bbf94b56dd2a0cd4" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the log verbosity level of PORT MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- PORT module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- PORT API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aeacb0e86f68ff55169aaf669657a22a1"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_log_verbosity_level_get" ref="aeacb0e86f68ff55169aaf669657a22a1" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the log verbosity level of PORT MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- PORT module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- PORT API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a320b05e1b217964e13862e3e20c48b22"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_device_set" ref="a320b05e1b217964e13862e3e20c48b22" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_device_id_t device_id, const sx_mac_addr_t *base_mac_addr_p, sx_port_attributes_t *port_attributes_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_device_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_device_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>base_mac_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_attributes_t *&#160;</td>
          <td class="paramname"><em>port_attributes_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API adds/deletes a device to/from the SDK. A device may have a different port width when using a single/double/quad lanes to provide 10/20/40GE. The mapping is done between the local port identifier and the module (cage) identifier that hosts this port. The SDK maps the device's local ports to (unique) logical ports that represent the SDK's ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_id</td><td>- device ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_mac_addr_p</td><td>- device base MAC address pointer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_attributes_list_p</td><td>- IN: port_mode, port_mapping OUT: log_port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- port attributes lists length</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceed its range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd></dl>

</div>
</div>
<a class="anchor" id="af2183e8bd9f2b4301c20dbc281152eb7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_device_get" ref="af2183e8bd9f2b4301c20dbc281152eb7" args="(const sx_api_handle_t handle, const sx_device_id_t device_id, const sx_swid_t swid, sx_port_attributes_t *port_attributes_list_p, uint32_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_device_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_device_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_attributes_t *&#160;</td>
          <td class="paramname"><em>port_attributes_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves a device information (port lists) from the SDK. If all optional output buffers are NULL, this API retrieves the number of ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_id</td><td>- device ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID (use SX_SWID_ID_DONTCARE to get all ports) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_attributes_list_p</td><td>- port attributes list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- IN: port attributes list length OUT:port attributes number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceed its range </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e0b743cdbcbe49a4486ae074352c62"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_device_base_mac_get" ref="aa2e0b743cdbcbe49a4486ae074352c62" args="(const sx_api_handle_t handle, const sx_device_id_t device_id, sx_mac_addr_t *base_mac_addr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_device_base_mac_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_device_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>base_mac_addr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves a device base MAC from the SDK. The base MAC is used as a base address for the ports MAC. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_id</td><td>- device ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">base_mac_addr_p</td><td>- device base MAC</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STAUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b5cce473414e8dd0cccff99f607937"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mapping_set" ref="ad6b5cce473414e8dd0cccff99f607937" args="(const sx_api_handle_t handle, const sx_port_log_id_t *log_port_list_p, const sx_port_mapping_t *port_mapping_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mapping_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_mapping_t *&#160;</td>
          <td class="paramname"><em>port_mapping_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets a ports mapping. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- list of local ports </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_mapping_list_p</td><td>- port mapping list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- number of ports</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceed its range </dd></dl>

</div>
</div>
<a class="anchor" id="ab6aac3d1a251bebecea8661d892ae138"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mapping_get" ref="ab6aac3d1a251bebecea8661d892ae138" args="(const sx_api_handle_t handle, const sx_port_log_id_t *log_port_list_p, sx_port_mapping_t *port_mapping_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mapping_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_mapping_t *&#160;</td>
          <td class="paramname"><em>port_mapping_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves logical port ID mapping from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- list of local ports </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_mapping_list_p</td><td>- port mapping list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- number of ports</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceed its range </dd></dl>

</div>
</div>
<a class="anchor" id="a8547e671b86adfa81b8914bc6d4a7c9a"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_device_list_get" ref="a8547e671b86adfa81b8914bc6d4a7c9a" args="(const sx_api_handle_t handle, sx_device_info_t *device_info_list_p, uint32_t *device_info_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_device_list_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_device_info_t *&#160;</td>
          <td class="paramname"><em>device_info_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>device_info_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the devices info list from the SDK. If optional output buffer is NULL, this API retrieves the number of devices. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_info_list_p</td><td>- list of device info entries </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_info_cnt_p</td><td>- In/Out: Input/output list length</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceed its range </dd></dl>

</div>
</div>
<a class="anchor" id="a5ac4e100b0a7e63857956f85f7564371"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_set" ref="a5ac4e100b0a7e63857956f85f7564371" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API adds/deletes a SWID to/from the SDK. A SWID which has bound ports cannot be deleted. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if SWID exceeds its range or is undefined in profile </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f581acd6ea7e53fa000614c679a3a2"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_list_get" ref="ae9f581acd6ea7e53fa000614c679a3a2" args="(const sx_api_handle_t handle, sx_swid_t *swid_list_p, uint32_t *swid_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_list_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_swid_t *&#160;</td>
          <td class="paramname"><em>swid_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>swid_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves all SWIDs lists from the SDK. If optional output buffer is NULL, this API retrieves the number of SWIDs. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swid_list_p</td><td>- array of SWIDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">swid_cnt_p</td><td>- In: Array's length Out: Number of SWIDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE: SwIDs list length is 0 (zero) </dd></dl>

</div>
</div>
<a class="anchor" id="a18e894e7fd6e658b8f268fefca4fd29b"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_bind_set" ref="a18e894e7fd6e658b8f268fefca4fd29b" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API binds/unbinds a logical port to/from a SWID in the SDK. To unbind a port from a SWID, the SWID field should be SX_SWID_ID_DISABLED. Port attributes are being reset during an unbind operation. For example, vlan membership and QinQ. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- new switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if SWID is out of range </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4fbd51ebc7bce4001fd347dd1128e3"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_bind_get" ref="a0b4fbd51ebc7bce4001fd347dd1128e3" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_swid_t *swid_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_swid_t *&#160;</td>
          <td class="paramname"><em>swid_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves a logical port's bound SWID. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">swid_p</td><td>- the port's swid</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if SWID is out of range </dd></dl>

</div>
</div>
<a class="anchor" id="ad157db98602e015414c58572fb807ce6"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_port_list_get" ref="ad157db98602e015414c58572fb807ce6" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_port_list_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the SwID's ports list. If optional output buffer is NULL - this API simply retrieves the number of Ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list</td><td>- array of device's logical port IDs range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- In: Array's length Out: Number of Ports in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if SWID is out of range </dd></dl>

</div>
</div>
<a class="anchor" id="a76a1283579d3589c1282db08adf9c15f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mode_set" ref="a76a1283579d3589c1282db08adf9c15f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port's stacking mode in the SDK. Supported devices: SwitchX, SwitchX2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>- new port mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a8915383346dfe6d396c27c2f4b02bb61"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mode_get" ref="a8915383346dfe6d396c27c2f4b02bb61" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_mode_t *mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_mode_t *&#160;</td>
          <td class="paramname"><em>mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's mode from the SDK. Supported devices: SwitchX, SwitchX2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode_p</td><td>- current port mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a177cc12ea300d6609cfce0d2affecbb7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mtu_set" ref="a177cc12ea300d6609cfce0d2affecbb7" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_mtu_t mtu_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mtu_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_mtu_t&#160;</td>
          <td class="paramname"><em>mtu_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port MTU size in the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical Port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtu_size</td><td>- new MTU size. The MTU size is L2 frame size (payload size + L2 header size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd></dl>

</div>
</div>
<a class="anchor" id="a30b32059620165e64aea03eeb674ffc0"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_mtu_get" ref="a30b32059620165e64aea03eeb674ffc0" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_mtu_t *max_mtu_size_p, sx_port_mtu_t *oper_mtu_size_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_mtu_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_mtu_t *&#160;</td>
          <td class="paramname"><em>max_mtu_size_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_mtu_t *&#160;</td>
          <td class="paramname"><em>oper_mtu_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port MTU size from the SDK. Note: for Ethernet, maximum MTU and operational MTU are the same. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_mtu_size_p</td><td>- maximum MTU supported on this port (L2 frame size) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_mtu_size_p</td><td>- operational MTU configured on this port (L2 frame size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a1eb11c6043ef0aaf7941b424c00bb2e9"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_speed_admin_set" ref="a1eb11c6043ef0aaf7941b424c00bb2e9" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_speed_capability_t *admin_speed_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_speed_admin_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_speed_capability_t *&#160;</td>
          <td class="paramname"><em>admin_speed_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port type &amp; speed. It enables the application to set the port enabled mode(s). When the link is up, the current active protocol is retrieved (after SET). When the link is down, the supported protocols are retrieved (after SET). Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">admin_speed_p</td><td>- new types and speeds (protocols) enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a9903aa3a1fec695b1df5a1afd9cce1fb"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_speed_get" ref="a9903aa3a1fec695b1df5a1afd9cce1fb" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_speed_capability_t *admin_speed_p, sx_port_oper_speed_t *oper_speed_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_speed_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_speed_capability_t *&#160;</td>
          <td class="paramname"><em>admin_speed_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_oper_speed_t *&#160;</td>
          <td class="paramname"><em>oper_speed_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's admin and operational speed from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">admin_speed_p</td><td>- port administrative speed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_speed_p</td><td>- Port Operational speed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="ac06ca456bb66a95dbd43b418f4455ce9"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_capability_get" ref="ac06ca456bb66a95dbd43b418f4455ce9" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_capability_t *capability_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_capability_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_capability_t *&#160;</td>
          <td class="paramname"><em>capability_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's supported capabilities from the SDK. HW capabilities are not configurable. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">capability_p</td><td>- port capabilities</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a02d492ab4853f76e8eb11bbe2178cd6f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_fec_capability_get" ref="a02d492ab4853f76e8eb11bbe2178cd6f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_fec_capability_t *fec_capability_list_p, uint32_t *fec_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_fec_capability_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_fec_capability_t *&#160;</td>
          <td class="paramname"><em>fec_capability_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>fec_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's supported FEC capabilities from the SDK Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fec_capability_list_p</td><td>- List of capabilities and corresponding speeds </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fec_cnt_p</td><td>- [in] Number of entries to get, [out] Number of entries in returned list If fec_capability_list is NULL or fec_cnt is 0 returns Count instead</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="af760dc1277fa07b46d3daa8ac75b5cd7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phys_addr_get" ref="af760dc1277fa07b46d3daa8ac75b5cd7" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_mac_addr_t *port_mac_addr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phys_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>port_mac_addr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API Retrieves the port's physical address (MAC) from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical Port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_mac_addr_p</td><td>- current base MAC address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="ae61ba2b35c7d6d649fdf09ca10e4a613"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phys_addr_set" ref="ae61ba2b35c7d6d649fdf09ca10e4a613" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_mac_addr_t *port_mac_addr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phys_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>port_mac_addr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port's physical address (MAC). Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_mac_addr_p</td><td>- new MAC address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a9c41fd0d58d3a1a376b19ea50e21a87d"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phys_loopback_set" ref="a9c41fd0d58d3a1a376b19ea50e21a87d" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phys_loopback_t phys_loopback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phys_loopback_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_phys_loopback_t&#160;</td>
          <td class="paramname"><em>phys_loopback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port's physical loopback. LAG port cannot be loopback. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phys_loopback</td><td>- new physical loopback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="acfda04376fd15f844335a23d60e84cba"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phys_loopback_get" ref="acfda04376fd15f844335a23d60e84cba" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_phys_loopback_t *phys_loopback_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phys_loopback_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_phys_loopback_t *&#160;</td>
          <td class="paramname"><em>phys_loopback_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's physical loopback. LAG port cannot be loopback. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phys_loopback_p</td><td>- current physical loopback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a086e428d40ce1a614e1684f7c1155875"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_state_set" ref="a086e428d40ce1a614e1684f7c1155875" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_admin_state_t admin_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_admin_state_t&#160;</td>
          <td class="paramname"><em>admin_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port administrative state in the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">admin_state</td><td>- new administrative status</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a538e5c6c74a875f9f6a29af53b40f6e7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_state_get" ref="a538e5c6c74a875f9f6a29af53b40f6e7" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_oper_state_t *oper_state_p, sx_port_admin_state_t *admin_state_p, sx_port_module_state_t *module_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_oper_state_t *&#160;</td>
          <td class="paramname"><em>oper_state_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_admin_state_t *&#160;</td>
          <td class="paramname"><em>admin_state_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_module_state_t *&#160;</td>
          <td class="paramname"><em>module_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's administrative, operational &amp; module state from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_state_p</td><td>- port operational state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">admin_state_p</td><td>- port administrative state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_state_p</td><td>- module operational state</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a242ad744d414037daa392640ac9ad43f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_global_fc_enable_set" ref="a242ad744d414037daa392640ac9ad43f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_mode_t fc_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_global_fc_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_flow_ctrl_mode_t&#160;</td>
          <td class="paramname"><em>fc_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port flow control pause configuration. ENUM sets the mode of both RX &amp; TX with one of 4 possible EN/DIS combinations. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>NOTE: When changing the port flow control configuration between the following states GLOBAL ON/GLOBAL OFF/PFC} the port administrative and operation state must be down.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID (whose flow control configuration to set) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_mode</td><td>- ENUM which represents the Tx/Rx flow control state</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a98768602683d64f5763f8db6964d6612"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_global_fc_enable_get" ref="a98768602683d64f5763f8db6964d6612" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_flow_ctrl_mode_t *fc_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_global_fc_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_flow_ctrl_mode_t *&#160;</td>
          <td class="paramname"><em>fc_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port flow control pause configuration from the SDK. ENUM gets the mode of both RX &amp; TX with one of 4 possible EN/DIS combinations. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID (whose flow control configuration to retrieve) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fc_mode_p</td><td>- ENUM which represents the Tx/Rx flow control state</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="ace8cc503f4eb1d6aa23489ccdcd5fd1e"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_pfc_enable_set" ref="ace8cc503f4eb1d6aa23489ccdcd5fd1e" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_prio_t pfc_prio, const sx_port_flow_ctrl_mode_t fc_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_pfc_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_flow_ctrl_prio_t&#160;</td>
          <td class="paramname"><em>pfc_prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_flow_ctrl_mode_t&#160;</td>
          <td class="paramname"><em>fc_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port priority flow control (PFC) configuration. ENUM sets the mode of both RX &amp; TX with one of 4 possible EN/DIS combinations. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>NOTE: When changing the port flow control configuration between the following states {GLOBAL ON/GLOBAL OFF/PFC} the port administrative and operation state must be down.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfc_prio</td><td>- PFC priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_mode</td><td>- ENUM which represents Tx/Rx flow control states</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a3a59090e625968bd111b29356454a66f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_pfc_enable_get" ref="a3a59090e625968bd111b29356454a66f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_flow_ctrl_prio_t pfc_prio, sx_port_flow_ctrl_mode_t *fc_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_pfc_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_flow_ctrl_prio_t&#160;</td>
          <td class="paramname"><em>pfc_prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_flow_ctrl_mode_t *&#160;</td>
          <td class="paramname"><em>fc_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port priority flow control (PFC) configuration the SDK. ENUM gets the mode of both RX &amp; TX with one of 4 possible EN/DIS combinations. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfc_prio</td><td>- PFC priority </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fc_mode_p</td><td>- ENUM which represents Tx/Rx flow control state</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="ab1da148241d2e8b5a7c3061995926d5d"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_ieee_802_dot_3_get" ref="ab1da148241d2e8b5a7c3061995926d5d" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_ieee_802_dot_3_t *cntr_ieee_802_dot_3_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_ieee_802_dot_3_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_ieee_802_dot_3_t *&#160;</td>
          <td class="paramname"><em>cntr_ieee_802_dot_3_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port IEEE 802.3 counters from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_ieee_802_dot_3_p</td><td>- IEEE 802.3 counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a3164c4dd6434ee771f6b2e38020bf82c"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_rfc_2863_get" ref="a3164c4dd6434ee771f6b2e38020bf82c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_2863_t *cntr_rfc_2863_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_rfc_2863_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_rfc_2863_t *&#160;</td>
          <td class="paramname"><em>cntr_rfc_2863_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port RFC 2863 counters from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_rfc_2863_p</td><td>- RFC 2863 counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ac4d9e0a2e66d1fde42fce0c0ce24e3bb"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_rfc_2819_get" ref="ac4d9e0a2e66d1fde42fce0c0ce24e3bb" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_2819_t *cntr_rfc_2819_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_rfc_2819_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_rfc_2819_t *&#160;</td>
          <td class="paramname"><em>cntr_rfc_2819_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port RFC 2819 counters from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_rfc_2819_p</td><td>- RFC 2819 counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="af164c75be838e07f152274206ce2b346"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_rfc_3635_get" ref="af164c75be838e07f152274206ce2b346" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_rfc_3635_t *cntr_rfc_3635_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_rfc_3635_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_rfc_3635_t *&#160;</td>
          <td class="paramname"><em>cntr_rfc_3635_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port RFC 3635 counters from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_rfc_3635_p</td><td>- RFC 3635 counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a20cb565fd4a0ebd4916f36ecf7125dec"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_cli_get" ref="a20cb565fd4a0ebd4916f36ecf7125dec" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_cli_t *cntr_cli_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_cli_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_cli_t *&#160;</td>
          <td class="paramname"><em>cntr_cli_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port CLI counters from the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_cli_p</td><td>- CLI counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a508d4c802af65d7ca579e82f74a97cf2"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_prio_get" ref="a508d4c802af65d7ca579e82f74a97cf2" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_cos_ieee_prio_t prio_id, sx_port_cntr_prio_t *cntr_prio_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_prio_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_ieee_prio_t&#160;</td>
          <td class="paramname"><em>prio_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_prio_t *&#160;</td>
          <td class="paramname"><em>cntr_prio_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port priority counters from the SDK. When a LAG port is given, the result is the sum of all the LAG ports counters. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_id</td><td>- priority ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_prio_p</td><td>- priority counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a48f6e4fc57d5892dba61185154c66446"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_tc_get" ref="a48f6e4fc57d5892dba61185154c66446" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_tc_id_t tc_id, sx_port_traffic_cntr_t *cntr_tc_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_tc_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_tc_id_t&#160;</td>
          <td class="paramname"><em>tc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_traffic_cntr_t *&#160;</td>
          <td class="paramname"><em>cntr_tc_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's traffic class counters. Note: The API does not support LAG nor VPORT.</p>
<p>For Spectrum device, in UC mode Tx UC octets and Tx UC frames counters are available only for TC ID 0 - 7.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tc_id</td><td>- traffic class ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_tc_p</td><td>- per port per TC counters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e6a9a3d90145c303b61bca3541c0c1"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_buff_get" ref="aa0e6a9a3d90145c303b61bca3541c0c1" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_cos_priority_group_t buff_id, sx_port_cntr_buff_t *cntr_buff_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_buff_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_priority_group_t&#160;</td>
          <td class="paramname"><em>buff_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_buff_t *&#160;</td>
          <td class="paramname"><em>cntr_buff_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port buffer counters from the SDK. When a LAG port is given, the result is the sum of all the LAG ports counters.</p>
<p>In UC mode Rx Uc octets, Rx UC frames, and Rx discard counters are available only for Buff ID 0 - 7. Shared buffer discard counter is not supported on Spectrum.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff_id</td><td>- buffer ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_buff_p</td><td>- buffer counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="aa5328e02b80e20924b025b3142ca546e"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_perf_get" ref="aa5328e02b80e20924b025b3142ca546e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_prio_id_t prio_id, sx_port_cntr_perf_t *cntr_perf_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_perf_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_prio_id_t&#160;</td>
          <td class="paramname"><em>prio_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_perf_t *&#160;</td>
          <td class="paramname"><em>cntr_perf_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API Retrieves the extended port counters from the SDK. Note: This API does not support LAG. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_id</td><td>- counters priority ID . In Spectrum only prio_id=0 is supported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_perf_p</td><td>- performance counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a5ea8fac313cd4a57dae8547c4fe676d7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_discard_get" ref="a5ea8fac313cd4a57dae8547c4fe676d7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_discard_t *cntr_discard_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_discard_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_discard_t *&#160;</td>
          <td class="paramname"><em>cntr_discard_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API Retrieves the port discard counters from the SDK. The user has the following options:</p>
<p>1. Read the discard counters (set the cmd to SX_ACCESS_CMD_READ) 2. Read and clear the discard counters (set the cmd to SX_ACCESS_CMD_READ_CLEAR)</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_discard_p</td><td>- discard counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sx_status_t : </dd>
<dd>
SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if a parameter is NULL or not supported </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd></dl>

</div>
</div>
<a class="anchor" id="a4b793ce2927cd10dee9fd39d0acf1e71"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_clear_set" ref="a4b793ce2927cd10dee9fd39d0acf1e71" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t all_ports, const sx_port_cntr_grp_t cntr_grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_clear_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>all_ports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_cntr_grp_t&#160;</td>
          <td class="paramname"><em>cntr_grp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API clears port counters. The user has the following options:</p>
<p>1. Clear a specific port (set log_port field with the log port ID &amp;&amp; all_ports = FALSE): option a. clear specific counter group (set the group in cntr_grp) option b. clear all counter groups (set cntr_grp = SX_PORT_CNTR_GRP_ALL)</p>
<p>2. Clear all ports (set all_ports = TRUE): option a. clear specific counter group (set the group in cntr_grp) option b. clear all counter groups (set cntr_grp = SX_PORT_CNTR_GRP_ALL)</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all_ports</td><td>- clear all ports counters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cntr_grp</td><td>- performance counter group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a64f3ed15b0f87c0f5791f4b777aa61e8"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_counter_phy_layer_get" ref="a64f3ed15b0f87c0f5791f4b777aa61e8" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_cntr_phy_layer_t *cntr_phy_layer_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_counter_phy_layer_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_cntr_phy_layer_t *&#160;</td>
          <td class="paramname"><em>cntr_phy_layer_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port Physical Layer counters from the SDK. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_READ | SX_ACCESS_CMD_READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cntr_phy_layer_p</td><td>- Physical Layer counters entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a239e0e4d8fcc7da1525bd29dfc7dda48"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_init_set" ref="a239e0e4d8fcc7da1525bd29dfc7dda48" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API initializes the port in the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="af4dbc06a2e2f50266cf07b01dae622a8"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_deinit_set" ref="af4dbc06a2e2f50266cf07b01dae622a8" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API de-initializes the port in the SDK. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_COMM_ERROR if client communication fails </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a78b976296aff6d5caec1ca9ec085d632"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_storm_control_set" ref="a78b976296aff6d5caec1ca9ec085d632" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, const sx_port_storm_control_params_t *storm_control_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_storm_control_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_storm_control_id_t&#160;</td>
          <td class="paramname"><em>storm_control_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_storm_control_params_t *&#160;</td>
          <td class="paramname"><em>storm_control_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets storm control parameters of a port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_ADD, SX_ACCESS_CMD_EDIT, SX_ACCESS_CMD_DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storm_control_id</td><td>- Storm Control ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storm_control_param_p</td><td>- Storm Control parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if HW fails </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="af0fd4ac374492bba4dce7fd46ae1d5fd"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_storm_control_get" ref="af0fd4ac374492bba4dce7fd46ae1d5fd" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, sx_port_storm_control_params_t *storm_control_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_storm_control_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_storm_control_id_t&#160;</td>
          <td class="paramname"><em>storm_control_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_storm_control_params_t *&#160;</td>
          <td class="paramname"><em>storm_control_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves storm control parameters of a port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storm_control_id</td><td>- Storm Control ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">storm_control_param_p</td><td>- Storm Control parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ab910ad0aeebae07d21c5e686febec8cb"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_storm_control_counters_clear_set" ref="ab910ad0aeebae07d21c5e686febec8cb" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, const sx_policer_counters_clear_t *clear_counters_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_storm_control_counters_clear_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_storm_control_id_t&#160;</td>
          <td class="paramname"><em>storm_control_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_policer_counters_clear_t *&#160;</td>
          <td class="paramname"><em>clear_counters_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears storm control counters values. Supported devices: Spectrum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storm_control_id</td><td>- Storm Control ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_counters</td><td>- which counters to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any other input error </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a50faf7675404b7b50880be9e94b0c638"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_storm_control_counters_get" ref="a50faf7675404b7b50880be9e94b0c638" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_storm_control_id_t storm_control_id, sx_policer_counters_t *policer_counters_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_storm_control_counters_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_storm_control_id_t&#160;</td>
          <td class="paramname"><em>storm_control_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_policer_counters_t *&#160;</td>
          <td class="paramname"><em>policer_counters_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves storm control counters values. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storm_control_id</td><td>- Storm Control ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">policer_counters_p</td><td>- pointer to a policer counter struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any other input error </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="abfca95b7b61f32a766a334b72477890e"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_sflow_set" ref="abfca95b7b61f32a766a334b72477890e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_sflow_params_t *sflow_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_sflow_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_sflow_params_t *&#160;</td>
          <td class="paramname"><em>sflow_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API controls sFlow configuration. Using the access command ADD, an sFlow sampling is defined on port. Then after it is set, the user may EDIT the sFlow parameters of a configured port. To remove sFlow sampling from the port use access command DELETE. The API returns the sFlow params configured in practice.Deviation is returned in percentage. It is highly recommended to always check the deviation value returned (SwitchX, SwitchX2 only).</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- access command (ADD/DELETE/EDIT) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sflow_params_p</td><td>- sFlow related configuration params (Deviation&gt;0); ignored when CMD=DESTROY</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are not enough resources for sFlow policer (SwitchX, SwitchX2 only) </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified port is not exist in DB or port not configured with sflow </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if sflow is requested for add on port already configured with sflow </dd>
<dd>
SX_STATUS_NO_MEMORY if there is no free memory </dd>
<dd>
SX_STATUS_WRONG_POLICER_TYPE if relevant policer is not bound (SwitchX, SwitchX2 only) </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if entry is already bound to policer (SwitchX, SwitchX2 only) </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a00b0a4e788461ae6bb1f20487adeadb6"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_sflow_get" ref="a00b0a4e788461ae6bb1f20487adeadb6" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_sflow_params_t *sflow_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_sflow_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_sflow_params_t *&#160;</td>
          <td class="paramname"><em>sflow_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the ports sFlow state. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sflow_params_p</td><td>- sFlow related configuration parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if sflow is requested for port not configured with sflow </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a258fa9e727c49b6bd37475942929ed0f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_sflow_statistics_get" ref="a258fa9e727c49b6bd37475942929ed0f" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_sflow_statistics_t *sflow_stat_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_sflow_statistics_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_sflow_statistics_t *&#160;</td>
          <td class="paramname"><em>sflow_stat_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the number of dropped packets from logical port or LAG. Supported devices: devices with dedicated HW for sflow sampling (currently Spectrum).</p>
<p>Packed dropped counter accumulates:</p>
<ul>
<li>packets dropped due to lack of host CPU RX buffer resources;</li>
<li>packets dropped by host CPU policers; Packed dropped counter does not accumulate:</li>
<li>packets dropped due to lack of shared buffer resources on duplication;</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- access command (READ/READ_CLEAR/CLEAR) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sflow_stat_p</td><td>- sFlow statistics related configuration parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if sflow is requested for port not configured with sflow </dd>
<dd>
SX_STATUS_NO_MEMORY if there is no free memory </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a47405313af00dc31c45b8bb570de9229"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_loopback_filter_set" ref="a47405313af00dc31c45b8bb570de9229" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_loopback_filter_mode_t lbf_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_loopback_filter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_loopback_filter_mode_t&#160;</td>
          <td class="paramname"><em>lbf_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API controls loopback filter state of the port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbf_mode</td><td>- loopback filter mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a156c5a50373b95c67fc62207cc368129"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_loopback_filter_get" ref="a156c5a50373b95c67fc62207cc368129" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_loopback_filter_mode_t *lbf_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_loopback_filter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_loopback_filter_mode_t *&#160;</td>
          <td class="paramname"><em>lbf_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the loopback filter state of the port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lbf_mode_p</td><td>- loopback filter mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="acab75e1ae238f36f3ac6c8c038c77c34"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_isolate_set" ref="acab75e1ae238f36f3ac6c8c038c77c34" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_log_id_t *log_port_list_p, const uint32_t log_port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_isolate_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>log_port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the isolation group of the port (a list of ports from which traffic should not be transmitted to log_port). Isolation is supported only between ports on the same device, and on the same SWID. Set - add ports to isolation group (overwrites previous configuration) Add - add ports to isolation group (additionally to previous configuration) Delete - remove ports from isolation group Delete All - empty isolation group</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- list of logical ports </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_cnt</td><td>- number of logical ports in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd></dl>

</div>
</div>
<a class="anchor" id="a44340edabf4a592c7b20760837532f3d"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_isolate_get" ref="a44340edabf4a592c7b20760837532f3d" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_log_id_t *log_port_list_p, uint32_t *log_port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_isolate_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>log_port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the isolation group of the port (a list of ports from which traffic should not be transmitted to log_port). Use log_port_cnt_p=0 to retrieve only the size of isolation group.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_port_list_p</td><td>- list of logical ports </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_port_cnt_p</td><td>- In: Number of logical ports in list Out: Number of logical ports in LAG</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd></dl>

</div>
</div>
<a class="anchor" id="ad40cb2f24f0db8d65dec6e1020c814e3"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_swid_type_get" ref="ad40cb2f24f0db8d65dec6e1020c814e3" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_swid_type_t *swid_type_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_swid_type_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_swid_type_t *&#160;</td>
          <td class="paramname"><em>swid_type_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API returns the SWID type as it was configured in the profile, at SDK init time. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swid</td><td>- switch partition ID </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swid_type_p</td><td>- DISABLED/ETHERNET/INFINIBAND</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd></dl>

</div>
</div>
<a class="anchor" id="a993301f3abf5d96ab7c5d638ea0a82fe"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_set" ref="a993301f3abf5d96ab7c5d638ea0a82fe" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_vlan_id_t vlan_id, sx_port_log_id_t *log_vport_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_id_t&#160;</td>
          <td class="paramname"><em>vlan_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_vport_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API creates a virtual port for port log_port and vlan vid. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- Port or LAG. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_id</td><td>- Vlan id. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_vport</td><td>- Logical port representing the virtual port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port does not exist OR vport for delete cmd. </dd>
<dd>
SX_STATUS_PARAM_ERROR if vid is not in the range. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if virtual port already exists. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no more room for vports to be added. </dd></dl>

</div>
</div>
<a class="anchor" id="abd0cfb324bd833a5e28129c67784da9e"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_get" ref="abd0cfb324bd833a5e28129c67784da9e" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vlan_id_t *vlan_id_list_p, uint32_t *vport_vlan_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vport_vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API returns the vport vlans created over the port. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- Port or LAG. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_id_p</td><td>- A list of all vlans created on the port. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vport_vlan_cnt_p</td><td>- The number of vport_vlans to return. If vport_vlan_cnt_p==0, Only the number of vport_vlans will be returned and the list will remain empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if log_port does not exist. </dd>
<dd>
SX_STATUS_PARAM_ERROR if vlan_list_p is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="afced2a9643b69573d9fd4420bad1d3ad"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_base_get" ref="afced2a9643b69573d9fd4420bad1d3ad" args="(const sx_api_handle_t handle, const sx_port_log_id_t vport, sx_vlan_id_t *vlan_id_p, sx_port_log_id_t *log_port_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_base_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>vport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API returns the base port and vlan properties for a given vport. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vport</td><td>- Vport logical ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_id_p</td><td>- Vlan. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_p</td><td>- Base port logical ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if vport does not exist. </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b08efe8e636733ebce2910ea3f14ef"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_counter_bind_set" ref="ae4b08efe8e636733ebce2910ea3f14ef" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t virtual_port, const sx_flow_counter_id_t flow_counter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>virtual_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>flow_counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API binds a flow counter to a virtual port. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">virtual_port</td><td>- Logical port representing the virtual port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flow_counter_id</td><td>- The flow counter ID to be bound to the virtual port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if vport or flow counter do not exist. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if virtual port already has a counter. </dd></dl>

</div>
</div>
<a class="anchor" id="a53a335bd4164f0d7b0ec3dd5ef0b4e86"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_counter_bind_get" ref="a53a335bd4164f0d7b0ec3dd5ef0b4e86" args="(const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, sx_flow_counter_id_t *flow_counter_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>virtual_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>flow_counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the flow counter bound to the virtual port. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">virtual_port</td><td>- Logical port representing the virtual port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_counter_id_p</td><td>- The flow counter ID bound to the virtual port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if vport or flow counter do not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e385909330b1a91c195bdfcfccf2ce5"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_mirror_set" ref="a6e385909330b1a91c195bdfcfccf2ce5" args="(const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, const sx_mirror_direction_t mirror_direction, const sx_mirror_mode_t mirror_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_mirror_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>virtual_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_mode_t&#160;</td>
          <td class="paramname"><em>mirror_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function sets the mirroring state for a virtual port. Currently only ingress direction is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">virtual_port</td><td>- mirroring vport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_mode</td><td>- enabled \ disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if virtual_port not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div>
<a class="anchor" id="afb429aafa04ed85e5067e1c260330cf8"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vport_mirror_get" ref="afb429aafa04ed85e5067e1c260330cf8" args="(const sx_api_handle_t handle, const sx_port_log_id_t virtual_port, const sx_mirror_direction_t mirror_direction, sx_mirror_mode_t *mirror_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vport_mirror_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>virtual_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mirror_mode_t *&#160;</td>
          <td class="paramname"><em>mirror_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supported devices: Spectrum This function gets the mirroring mode for a virtual port by direction. Currently only ingress direction is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. @ param[in] virtual_port - mirroring vport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress/egress </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mirror_mode_p</td><td>- the returned mirroring mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if virtual_port is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a class="anchor" id="ae7497db77430915b70638c5643044a66"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phy_mode_set" ref="ae7497db77430915b70638c5643044a66" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phy_speed_t speed, const sx_port_phy_mode_t admin_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phy_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_phy_speed_t&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_phy_mode_t&#160;</td>
          <td class="paramname"><em>admin_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port's phy mode in the SDK. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>- Phy Speed - 10G/40G/25G/50G/100G Note: Changing the FEC mode of 25G speed also sets 50G speed mode and vice versa. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>- new phy admin mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="af025d901dace3b52c1c96874cdb54250"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_phy_mode_get" ref="af025d901dace3b52c1c96874cdb54250" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_phy_speed_t speed, sx_port_phy_mode_t *admin_mode_p, sx_port_phy_mode_t *oper_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_phy_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_phy_speed_t&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_phy_mode_t *&#160;</td>
          <td class="paramname"><em>admin_mode_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_phy_mode_t *&#160;</td>
          <td class="paramname"><em>oper_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's phy mode from the SDK. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>- Phy Speed - 10G/40G/25G/50G/100G </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">admin_mode_p</td><td>- current port Admin phy mode. Administrative phy mode is per speed (i.e. Speed is required for the administrative value). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_mode_p</td><td>- current port Operational phy mode.Operational phy mode is global and not per speed (i.e Speed is don't care for the operational value).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a8d7eba93b6d86d73d3f15c6a070d9ee6"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_discard_reason_get" ref="a8d7eba93b6d86d73d3f15c6a070d9ee6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_port_discard_reason_t *discard_reason_list_p, const uint32_t list_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_discard_reason_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_discard_reason_t *&#160;</td>
          <td class="paramname"><em>discard_reason_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>list_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API enables to read/clear discard reason</p>
<p>Supported devices: Spectrum</p>
<p>This release does not support the following causes: ip_discard: sx_port_cause_t packet_to_router_is_not_ip sx_port_cause_t dip_is_loopback sx_port_cause_t sip_is_in_class sx_port_cause_t sip is loopback sx_port_cause_t ip header not okay sx_port_cause_t ipv4 sip is limited broadcast sx_port_cause_t lpm ipv6 miss sx_port_cause_t IPv4 dip is limited broadcast sx_port_cause_t IPv4 dip is local sx_port_cause_t NVE packet to overlay router</p>
<p>MPLS_discard: sx_port_cause_t outer_label_is_not_valid sx_port_cause_t no_IP_after_decap sx_port_cause_t expected_Bos_but_pop_did_not_expose_BoS; sx_port_cause_t php_decap_and_no_ip_header_or_ip_header_is_not_okay</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">discard_reason_list_p</td><td>- array of discard reason </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_count</td><td>- array's length</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received O/W, the appropriate error code it returned. </dd></dl>

</div>
</div>
<a class="anchor" id="afd76c376d228a7132221481c9ac2c52d"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_forwarding_mode_set" ref="afd76c376d228a7132221481c9ac2c52d" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_forwarding_mode_t admin_fwd_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_forwarding_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_forwarding_mode_t&#160;</td>
          <td class="paramname"><em>admin_fwd_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the port's forwarding mode (cut-through vs. store-and-forward) in the SDK. Note: Port operational forwarding mode will be updated only after port toggling. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical Port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">admin_fwd_mode</td><td>- new administrative forwarding mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a6faebd4529a3119a93941b51ff63213c"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_forwarding_mode_get" ref="a6faebd4529a3119a93941b51ff63213c" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_forwarding_mode_t *admin_fwd_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_forwarding_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_forwarding_mode_t *&#160;</td>
          <td class="paramname"><em>admin_fwd_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the port's forwarding mode (cut-through vs. store-and-forward) from the SDK. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">admin_fwd_mode_p</td><td>- administrative forwarding mode configured on this port</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a994472bd0de2e3bbd71a4090a7fb853a"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_parsing_depth_set" ref="a994472bd0de2e3bbd71a4090a7fb853a" args="(const sx_api_handle_t handle, const uint16_t parsing_depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_parsing_depth_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>parsing_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API set the chip parsing depth in bytes . Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parsing_depth</td><td>- parsing depth in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a7787e441d72b3923373592cedfa66b8f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_parsing_depth_get" ref="a7787e441d72b3923373592cedfa66b8f" args="(const sx_api_handle_t handle, uint16_t *parsing_depth_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_parsing_depth_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>parsing_depth_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the chip parsing depth . Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parsing_depth_p</td><td>- return parsing depth in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="ad81cab6adb1ff0e9e00da8b71a9c0dc7"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vlan_ethertype_set" ref="ad81cab6adb1ff0e9e00da8b71a9c0dc7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_vlan_ethertype_t *ether_types_list_p, uint32_t ether_type_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vlan_ethertype_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_ethertype_t *&#160;</td>
          <td class="paramname"><em>ether_types_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ether_type_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to set Ethertypes globally. Note that Ethertype 0x8100 will always be configured by default. This API allows the user to configure additional Ethertypes per function.</p>
<p>Supported devices: Spectrum </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ether_types_p</td><td>- a pointer to struct holding a list of ether_types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ether_type_count</td><td>- number of Ethertypes being configured (Max 1 in Spectrum)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any of the parameters are in Error. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no resources are available </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a DELETE is called on a non-existent Ethertype </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a DELETE is called while a resource is in use </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2c1c1165721f2dd979baaad7aa06c8"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_vlan_ethertype_get" ref="a9e2c1c1165721f2dd979baaad7aa06c8" args="(const sx_api_handle_t handle, sx_vlan_ethertype_t *ether_types_list_p, uint32_t *ether_type_count_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_vlan_ethertype_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_ethertype_t *&#160;</td>
          <td class="paramname"><em>ether_types_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ether_type_count_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets a list of user configured Ethertypes. Note that 0x8100 is always configured and will not be retrieved. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ether_types_p</td><td>- a pointer to struct to hold the retrieved list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ether_type_count</td><td>- number of Ethertypes being retrieved. If ether_type_count==0,returns count instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any of the parameters are in Error. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a5cde445f80ba07b374ec43d429258213"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ber_threshold_set" ref="a5cde445f80ba07b374ec43d429258213" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_fec_profile_e fec_profile, const sx_port_ber_fec_profile_threshold_data_t threshold_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ber_threshold_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_ber_fec_profile_e&#160;</td>
          <td class="paramname"><em>fec_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_ber_fec_profile_threshold_data_t&#160;</td>
          <td class="paramname"><em>threshold_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to set values to the different Bit Error Rate profiles. Supported devices: Spectrum.</p>
<p>Min/max values: |--------------------------------| | Monitor | Min | Max | |--------------------------------| |RS-FEC Pre-FEC | 1e-9 | 1e-4 | |--------------------------------| |FC-FEC PRE-FEC | 1e-11 | 1e-4 | |--------------------------------| |NO-FEC/Post-FEC | 1e-14 | 1e-8 | |--------------------------------|</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- Network port only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fec_profile</td><td>- The FEC profile to be used (RS/FC/NO). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_data</td><td>- Threshold values to set. Values of fraction of errors. Final BER monitor threshold should be between 0 and 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f667dd7b660b94b62792c1ae69e5fce"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ber_threshold_get" ref="a8f667dd7b660b94b62792c1ae69e5fce" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_fec_profile_e fec_profile, sx_port_ber_fec_profile_threshold_data_t *threshold_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ber_threshold_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_ber_fec_profile_e&#160;</td>
          <td class="paramname"><em>fec_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_ber_fec_profile_threshold_data_t *&#160;</td>
          <td class="paramname"><em>threshold_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to retrieve values of the different Bit Error Rate profiles. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- Network port only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fec_profile</td><td>- The FEC profile to retrieve (RS/FC/NO). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threshold_data_p</td><td>- Threshold values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8fe894b0b098f71d6dc7377857f704"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ber_monitor_set" ref="a1b8fe894b0b098f71d6dc7377857f704" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_ber_monitor_data_t monitor_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ber_monitor_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_ber_monitor_data_t&#160;</td>
          <td class="paramname"><em>monitor_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to configure the Bit Error Rate Monitor. It is recommended to use sx_api_port_ber_monitor_operational_get after configuring this API to retrieve the FEC status that is configured. This API is orthogonal to the port FEC configuration. It is recommended to first register to SX_TRAP_ID_BER_MONITOR and then setting the monitor data so the first event will be the current status. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- The port to which to set the monitor. Only network ports are supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monitor_data</td><td>- The monitor attributes to configure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a24be4d40087906caa89dd9da0c42bec1"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ber_monitor_get" ref="a24be4d40087906caa89dd9da0c42bec1" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_ber_monitor_data_t *monitor_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ber_monitor_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_ber_monitor_data_t *&#160;</td>
          <td class="paramname"><em>monitor_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to retrieve values configured to the Bit Error Rate Monitor. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- The port to which the monitor is configured. Only network ports are supported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">monitor_data_p</td><td>- Structure to hold the desired data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a90aed399a13799019672e507f020e62e"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ber_monitor_operational_get" ref="a90aed399a13799019672e507f020e62e" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_ber_monitor_oper_data_t *monitor_oper_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ber_monitor_operational_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_ber_monitor_oper_data_t *&#160;</td>
          <td class="paramname"><em>monitor_oper_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to retrieve the current state of the Bit Error Rate Monitor. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- The port to which the monitor is configured. Only network ports are supported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">monitor_oper_data_p</td><td>- Structure to hold the desired data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if cannot allocate resources. </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a4862f48efbaf9707fe354b1f5b42f2f8"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_sll_set" ref="a4862f48efbaf9707fe354b1f5b42f2f8" args="(const sx_api_handle_t handle, const uint64_t sll_max_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_sll_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>sll_max_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SLL is the max lifetime of a frame within the switch after which it is discarded. This function SETs the sll_max_time in microseconds.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sll_max_time</td><td>- The sll duration in micro seconds Min val = 32usec. Max val = 4398046511 usec (or 4398sec) Any value greater than max implies NO SLL i.e packets are never aged &amp; discarded. SDK will round the sll duration to: (the lowest power of 2 &gt;= sll) * 4.096 For e.g. 500000 will be rounded up to 536871</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a47cddb263aaa3520ba641e528f138acc"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_sll_get" ref="a47cddb263aaa3520ba641e528f138acc" args="(const sx_api_handle_t handle, uint64_t *sll_max_time_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_sll_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>sll_max_time_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SLL is the max lifetime of a frame within the switch after which it is discarded. This function GETs the system sll_max_time in microseconds.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sll_max_time_p</td><td>- The sll duration in micro seconds .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="afd7e583a74d6398fbb03edf451688d1c"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_hll_set" ref="afd7e583a74d6398fbb03edf451688d1c" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const uint32_t hll_max_time, const uint32_t hll_stall_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_hll_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hll_max_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hll_stall_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>HLL is a mechanism that discards packets that are awaiting transmission at the head of a scheduling group queue. The max duration a packet can wait in the queue is configurable After a certain number of packets are discarded, this scheduling group may enter the STALL state if enabled. This function SETs hll_max_time and the hll_stall_cnt for a given port</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- the local port. Only Physical ports and LAG Ports are allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hll_max_time</td><td>- The HLL duration in micro seconds. Min val = 4usec. Max val = 2147483usec (or 2sec) Any value greater than max implies infinite HLL(or No HLL) SDK will round the hll time to: (the lowest power of 2 &gt;= hll) * 4.096 For e.g. 10000 will be rounded up to 16777 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hll_stall_cnt</td><td>- Number of packets that need to be discarded after which the queue enters stall state. Valid range [0-7]; Default = 7; 0 = Stall Disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR if unexpected behavior occurs </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="acb57f0fe402abeb9d42d47ac6a575762"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_hll_get" ref="acb57f0fe402abeb9d42d47ac6a575762" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *hll_max_time_p, uint32_t *hll_stall_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_hll_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hll_max_time_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hll_stall_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>HLL is a mechanism that discards packets that are awaiting transmission at the head of a scheduling group queue. The max duration a packet can wait in the queue is configurable After a certain number of packets are discarded, this scheduling group may enter the STALL state if enabled. This function GETs hll_max_time and the hll_stall_cnt for a given port</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- the local port. Only Physical ports and LAG Ports are allowed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hll_max_time_p</td><td>- The HLL duration in micro seconds rounded up to: ((nearest power of 2) * 4.096) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hll_stall_cnt_p</td><td>- Number of packets that need to be discarded after which the queue enters stall state. Valid range [0-7]; 0 = Stall Disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR if unexpected behavior occurs </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ac3aec8abde92ea8e8d6fa29b3a598b93"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_crc_params_set" ref="ac3aec8abde92ea8e8d6fa29b3a598b93" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_port_crc_params_t *crc_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_crc_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_crc_params_t *&#160;</td>
          <td class="paramname"><em>crc_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the options for how the port handles CRCs in the SDK. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical Port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crc_params</td><td>- CRC handling options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a334fed1bc4eeccb5066c6c68fa56016f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_crc_params_get" ref="a334fed1bc4eeccb5066c6c68fa56016f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_port_crc_params_t *crc_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_crc_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_crc_params_t *&#160;</td>
          <td class="paramname"><em>crc_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the current options for how the port handles CRCs in the SDK. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical Port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crc_params</td><td>- CRC handling options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd></dl>

</div>
</div>
<a class="anchor" id="a52a7bc5480bebf78a68b16cfa7338f9d"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ptp_params_set" ref="a52a7bc5480bebf78a68b16cfa7338f9d" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_ptp_params_t *port_ptp_params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ptp_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_ptp_params_t *&#160;</td>
          <td class="paramname"><em>port_ptp_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets PTP port parameters Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_EDIT : change grand master port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- The log port to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_ptp_params</td><td>- The ptp port parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aeeaf90f48d243537a9ace172db9c818f"></a><!-- doxytag: member="sx_api_port.h::sx_api_port_ptp_params_get" ref="aeeaf90f48d243537a9ace172db9c818f" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, sx_port_ptp_params_t *port_ptp_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_port_ptp_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_ptp_params_t *&#160;</td>
          <td class="paramname"><em>port_ptp_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets PTP port role Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_GET : change grand master port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- The log port to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_ptp_params</td><td>- The ptp port parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Fri Jan 26 2018 10:07:25 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
