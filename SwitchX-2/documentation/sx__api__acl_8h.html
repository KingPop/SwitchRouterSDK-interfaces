<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_acl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.3002</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_acl.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__acl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aadfc89bd1ed719720aef093a6d27aef0">sx_api_acl_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1b19d38aaad622638cc25ffc1e861e53">sx_api_acl_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#abeff59071f650e6e79d3d84a2466aef1">sx_api_acl_region_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_type_t key_type, const sx_acl_action_type_t action_type, const sx_acl_size_t region_size, sx_acl_region_id_t *region_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6b49b3d09fd3e0e105abe4927a5c602d">sx_api_acl_region_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_key_type_t *key_type_p, sx_acl_action_type_t *action_type_p, sx_acl_size_t *region_size_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3d3eac6c48940390d6b9fbd8e4c9326c">sx_api_acl_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_type_t acl_type, const sx_acl_direction_t acl_direction, const sx_acl_region_group_t *acl_region_group_p, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a21db595169c45f866832b88844cb9f1f">sx_api_acl_get</a> (const sx_api_handle_t handle, const sx_acl_id_t acl_id, sx_acl_type_t *acl_type_p, sx_acl_direction_t *acl_direction_p, sx_acl_region_group_t *acl_region_group_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#acc922fb9cf64214d703db802ca91bf32">sx_api_acl_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_direction_t acl_direction, const sx_acl_id_t *acl_id_list_p, const uint32_t acl_id_cnt, sx_acl_id_t *group_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab7ecf2ea6914f57c8b24fc288b6aec40">sx_api_acl_group_get</a> (const sx_api_handle_t handle, const sx_acl_id_t group_id, sx_acl_direction_t *acl_direction_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af7f1841f9e865b353f5dc6742212b4a0">sx_api_acl_policy_based_switching_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_entry_t *pbs_entry_p, sx_acl_pbs_id_t *pbs_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1d3627a7131f363300617de31f7edc3b">sx_api_acl_policy_based_switching_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_id_t pbs_id, sx_acl_pbs_entry_t *pbs_entry_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1395c6e1613b712e9854f4e982ff8a62">sx_api_acl_l4_port_range_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_entry_t *l4_port_range_p, sx_acl_port_range_id_t *range_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ad1c17eb4b9b274fddb09c13f1514c289">sx_api_acl_l4_port_range_get</a> (const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_port_range_entry_t *l4_port_range_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a85de9c7f09f1494b0af588835ba5febb">sx_api_acl_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_t *rules_list_p, const uint32_t rules_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8a71f177218829d87debe98d4c399238">sx_api_acl_rules_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t start_offset, sx_acl_rule_t *rules_list_p, uint32_t *rules_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aae2d4dde1a42506c57445dedaa2934d7">sx_api_acl_rule_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t rule_offset, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a022e95843912425808dcbb26058e6c5f">sx_api_acl_rule_block_move_set</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t block_start, const sx_acl_size_t block_size, const sx_acl_rule_offset_t new_block_start)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a92286cc3f4baf42e3f97ad25c380ffb6">sx_api_acl_port_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_acl_id_t acl_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a9543188e428bed340f419ed050a47277">sx_api_acl_port_bind_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6cfe4cc96f0de7b65e2a46603fc1b78a">sx_api_acl_vlan_group_map_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_vlan_id_t *vlan_list_p, const uint32_t vlan_cnt, sx_acl_vlan_group_t *group_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2943e03e105609c89d70865940ddf9c4">sx_api_acl_vlan_group_map_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_acl_vlan_group_t group_id, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3f5727bed5f37c11a2691483d3f368c9">sx_api_acl_vlan_group_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_vlan_group_t vlan_group, const sx_acl_id_t acl_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab91d548d2e1386edee4e5e4fd6c0813a">sx_api_acl_vlan_group_bind_get</a> (const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aaba4b8d2a4b0e13541c5d2dc33caead5">sx_api_acl_flex_key_attr_get</a> (const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_flex_key_attr_t *key_attr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a77d6ceeb4c13e21075e9e25eb631976b">sx_api_acl_flex_key_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_t *key_list_p, const uint32_t key_count, sx_acl_key_type_t *key_handle_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af92b255d5ce7a24c8527cd55f61d8da1">sx_api_acl_flex_key_get</a> (const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_key_t *key_list_p, uint32_t *key_count_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#acbf34d5037f1494d0c146ada9f407840">sx_api_acl_flex_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, const sx_flex_acl_flex_rule_t *rules_list_p, const uint32_t rules_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a7820db61cf02508199106ad6b52562af">sx_api_acl_flex_rules_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, sx_flex_acl_flex_rule_t *rules_list_p, uint32_t *rules_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a5affcc85683c3ceca56d5b2bfdc81a95">sx_api_acl_rif_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_rif_id_t rif_id, const sx_acl_id_t acl_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a82890bcca35387bcad58a4cc8be18c4d">sx_api_acl_rif_bind_get</a> (const sx_api_handle_t handle, const sx_rif_id_t rif_id, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8d75e017d9af517108026cd99b68ece9">sx_api_acl_group_bind_set</a> (sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_id_t group_id, sx_acl_id_t next_group_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aece9f1a820e5fe724e91b5ae46eac747">sx_api_acl_group_bind_get</a> (sx_api_handle_t handle, sx_acl_id_t group_id, sx_acl_id_t *group_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab8f2477244a41031b345572131287a04">sx_api_acl_port_list_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_port_list_entry_t *port_list_p, const uint32_t port_list_cnt, sx_acl_port_list_id_t *port_list_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1f73a62d89a23869e37faf3fa8933a60">sx_api_acl_port_list_get</a> (const sx_api_handle_t handle, const sx_acl_port_list_id_t port_list_id, sx_acl_port_list_entry_t *port_list_p, uint32_t *port_list_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab93629cae18b47ab7681567547431c5c">sx_api_acl_region_hw_size_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_size_t *region_size_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aadfc89bd1ed719720aef093a6d27aef0"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_log_verbosity_level_set" ref="aadfc89bd1ed719720aef093a6d27aef0" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the log verbosity level of ACL MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a1b19d38aaad622638cc25ffc1e861e53"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_log_verbosity_level_get" ref="a1b19d38aaad622638cc25ffc1e861e53" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the log verbosity level of ACL MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="abeff59071f650e6e79d3d84a2466aef1"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_region_set" ref="abeff59071f650e6e79d3d84a2466aef1" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_type_t key_type, const sx_acl_action_type_t action_type, const sx_acl_size_t region_size, sx_acl_region_id_t *region_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_action_type_t&#160;</td>
          <td class="paramname"><em>action_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>region_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_id_t *&#160;</td>
          <td class="paramname"><em>region_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to create ACL region (rules list). for creation use command CREATE and supply key_type and size. acl_region_id is returned on successful creation. for destroying an ACL region it is required that the ACL region is not bound and the acl_region_id should be provided. EDIT command is used for resizing an existing ACL region. acl_region_id and new size should be provided. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY / EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_type</td><td>- key type used in this ACL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action_type</td><td>- type of actions to be used in this ACL block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_size</td><td>- maximal number of rules in this ACL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">region_id_p</td><td>- ACL region ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a6b49b3d09fd3e0e105abe4927a5c602d"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_region_get" ref="a6b49b3d09fd3e0e105abe4927a5c602d" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_key_type_t *key_type_p, sx_acl_action_type_t *action_type_p, sx_acl_size_t *region_size_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_type_t *&#160;</td>
          <td class="paramname"><em>key_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_action_type_t *&#160;</td>
          <td class="paramname"><em>action_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_size_t *&#160;</td>
          <td class="paramname"><em>region_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL region properties . Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_type_p</td><td>- key type used in this ACL region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">action_type_p</td><td>- type of actions used in this ACL region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">region_size_p</td><td>- maximal number of rules in this ACL region</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3eac6c48940390d6b9fbd8e4c9326c"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_set" ref="a3d3eac6c48940390d6b9fbd8e4c9326c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_type_t acl_type, const sx_acl_direction_t acl_direction, const sx_acl_region_group_t *acl_region_group_p, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_type_t&#160;</td>
          <td class="paramname"><em>acl_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to create a single region ACL. Use CREATE access command for creating a new ACL, it will return an ACL id. DESTROY command may be used when the ACL is not bound to HW. Packet sensitive ACL is currently NOT supported. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_type</td><td>- ACL type of this ACL (AGNOSTIC). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction (ingress or egress port or ingress or egress RIF ACL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group matching ACL type </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- ACL ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a21db595169c45f866832b88844cb9f1f"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_get" ref="a21db595169c45f866832b88844cb9f1f" args="(const sx_api_handle_t handle, const sx_acl_id_t acl_id, sx_acl_type_t *acl_type_p, sx_acl_direction_t *acl_direction_p, sx_acl_region_group_t *acl_region_group_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_type_t *&#160;</td>
          <td class="paramname"><em>acl_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL attributes . The ACL id is given and the function returns ACL attributes : type and a list of attached regions. the length of the regions list depends on the ACL type Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_type_p</td><td>- ACL type (packet agnostic or packet sensitive) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction_p</td><td>- ACL direction (ingress or egress ACL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group attached to the ACL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="acc922fb9cf64214d703db802ca91bf32"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_group_set" ref="acc922fb9cf64214d703db802ca91bf32" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_direction_t acl_direction, const sx_acl_id_t *acl_id_list_p, const uint32_t acl_id_cnt, sx_acl_id_t *group_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>acl_id_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for controlling a group of ACL or in other words cascaded ACL blocks up to the size of SX_ACL_MAX_ACL_GROUP_SIZE. When using CREATE command user must supply the ACL group direction. A new group is allocated and a free group ID is returned. Use SET command to define an ordered cascaded ACLs group (ACLs must be in the same direction as the group). SET Can be also used for editing an ACL group. DESTROY command will free the list resource. It is allowed only when the ACL list is not bound in HW. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / SET / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL group direction (ingress or egress ACLs). All ACLs in this group must have the same direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_list_p</td><td>- ordered list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_cnt</td><td>- number of elements in the list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- ACL group ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no group is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="ab7ecf2ea6914f57c8b24fc288b6aec40"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_group_get" ref="ab7ecf2ea6914f57c8b24fc288b6aec40" args="(const sx_api_handle_t handle, const sx_acl_id_t group_id, sx_acl_direction_t *acl_direction_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL group attributes . the ACL group id is given and the function returns ACL group attributes : direction and a list of attached ACLs. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- ACL group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction</td><td>- ACL direction (ingress or egress ACL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_list_p</td><td>- list of the group ACL IDs. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_cnt_p</td><td>- In - size of the ACL IDs array, OUT - number of valid ACL IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a class="anchor" id="af7f1841f9e865b353f5dc6742212b4a0"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_policy_based_switching_set" ref="af7f1841f9e865b353f5dc6742212b4a0" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_entry_t *pbs_entry_p, sx_acl_pbs_id_t *pbs_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_id_t *&#160;</td>
          <td class="paramname"><em>pbs_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/edits/deletes a policy based switching (PBS) set . Policy based switching entry can be later bound to an ACL rule in order to specify destination port/port group (multicast) or send the frame to the router block / fcf block. Use ADD command to create a PBS entry, note that this operation may fail if no HW resources are available. PBS entry can be created without ports in order to ensure future HW resource availability. Use ADD_PORTS and DELETE_PORTS access command to edit the entry</p>
<ul>
<li>unicast entry can have up to 1 port only. Use DELETE command to clear a PBS record (not allowed when this record is in use by ACL rules) Supported devices: SwitchX, SwitchX2, Spectrum.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / ADD_PORTS / DELETE_PORTS / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_entry</td><td>- struct for PBS attributes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no HW resources for PBS creation </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if the PBS record is in use </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a1d3627a7131f363300617de31f7edc3b"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_policy_based_switching_get" ref="a1d3627a7131f363300617de31f7edc3b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_id_t pbs_id, sx_acl_pbs_entry_t *pbs_entry_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_id_t&#160;</td>
          <td class="paramname"><em>pbs_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get a PBS set or to count ports of a PBS set. note that for GET command the pbs_entry should be pre-allocated and pbs_entry port_num should be updated to maximal port count to get. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- COUNT / GET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID of the PBS entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_id</td><td>- Port based switching entry ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_entry</td><td>- struct for Policy based switching entry attributes. IN - max port number to retrieve. OUT</p>
<ul>
<li>actual number of ports retrieved.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a1395c6e1613b712e9854f4e982ff8a62"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_l4_port_range_set" ref="a1395c6e1613b712e9854f4e982ff8a62" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_entry_t *l4_port_range_p, sx_acl_port_range_id_t *range_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_id_t *&#160;</td>
          <td class="paramname"><em>range_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/edits/deletes a Layer 4 port range comparison set (up to SX_ACL_MAX_PORT_RANGES). Use this comparison set for ACL IPv4 IPv6 full key. When ADD command is used the given ranges are written into a group and its ID is returned. When EDIT command is used the given range is written into a group of range_index. When DELETE command is used the given range_index configuration is cleared. Port range comparison set cannot be deleted if it is applied to an acl rule. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / EDIT / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="ad1c17eb4b9b274fddb09c13f1514c289"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_l4_port_range_get" ref="ad1c17eb4b9b274fddb09c13f1514c289" args="(const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_port_range_entry_t *l4_port_range_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_id_t&#160;</td>
          <td class="paramname"><em>range_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get a Layer 4 port range comparison set. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id</td><td>- Port range comparison ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a class="anchor" id="a85de9c7f09f1494b0af588835ba5febb"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rules_set" ref="a85de9c7f09f1494b0af588835ba5febb" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_t *rules_list_p, const uint32_t rules_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rules_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for inserting rules into an ACL region. Inserting rules is allowed before and after bind operation. Rule is inserted to an explicit offset, overriding existing rule on that offset. Rules must have the same key type as the ACL region. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) in rules[].key.fields.key_type.vid (if present in the key_type) and rules[].mask.fields.key_type.vid (if present) and rules[].action.basic_action.vid (if present), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_p</td><td>- array of structs representing rule content. should be in size of num_of_rules </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_rules</td><td>- number of rules to configure (number of elements in the array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no more space for rules </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a8a71f177218829d87debe98d4c399238"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rules_get" ref="a8a71f177218829d87debe98d4c399238" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t start_offset, sx_acl_rule_t *rules_list_p, uint32_t *rules_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rules_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting rules of an ACL block.</p>
<p>When in 802.1D mode, instead of receiving a vid(Vlan ID), on rules[].key.fields.key_type.vid, rules[].mask.fields.key_type.vid and rules[].action.basic_action.vid, a bridge_id's are provided. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_offset</td><td>- Start offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rules_p</td><td>- pointer to array of structs representing rule content. should be in size of num_of_rules. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">num_of_rules</td><td>- IN - number of rules to get (number of elements in the array), OUT - number of rules that were actually read from ACL table</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure requested </dd></dl>

</div>
</div>
<a class="anchor" id="aae2d4dde1a42506c57445dedaa2934d7"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rule_activity_get" ref="aae2d4dde1a42506c57445dedaa2934d7" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t rule_offset, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>rule_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting the activity of a specific rule. If the region is not bound, activity_p is invalid. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule_offset</td><td>- ACL Rule offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- ACL Rule activity</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure requested </dd></dl>

</div>
</div>
<a class="anchor" id="a022e95843912425808dcbb26058e6c5f"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rule_block_move_set" ref="a022e95843912425808dcbb26058e6c5f" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t block_start, const sx_acl_size_t block_size, const sx_acl_rule_offset_t new_block_start)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_block_move_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>new_block_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for moving a block of rules within an ACL region. Moving is allowed before and after ACL bind. Moving a block does not affect search hits, but may override existing rules if such exist on the new block location. Non-valid rules within the block are moved as well. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_start</td><td>- Rules block start offset within the ACL block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>- Number of rules to move within the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block_start</td><td>- New offset of the first rule of the given rules block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd></dl>

</div>
</div>
<a class="anchor" id="a92286cc3f4baf42e3f97ad25c380ffb6"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_port_bind_set" ref="a92286cc3f4baf42e3f97ad25c380ffb6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_acl_id_t acl_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to bind/unbind ACL or ACL group to a port (or LAG). Binding more than one ACL to port may be achieved by using ACL groups. Binding may fail if there is no place for the ACL in HW Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID given for ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a9543188e428bed340f419ed050a47277"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_port_bind_get" ref="a9543188e428bed340f419ed050a47277" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or ACL group which is bound to a specific port Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port is not bound </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfe4cc96f0de7b65e2a46603fc1b78a"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_vlan_group_map_set" ref="a6cfe4cc96f0de7b65e2a46603fc1b78a" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_vlan_id_t *vlan_list_p, const uint32_t vlan_cnt, sx_acl_vlan_group_t *group_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vlan_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_vlan_group_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for controlling mapping of vlans into vlan groups for ACL binding. CREATE command used for creating a new group, will return a free group ID if such exist ADD / DELETE commands are used to control mapping of SWID,VID to an existing vlan group DESTROY command is used to free a vlan group resource</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / ADD / DELETE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID (used only with ADD/DELETE) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_list</td><td>- a list of vlans to attach to this group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_num</td><td>- number of elements in the vlan list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no group is available to create </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="a2943e03e105609c89d70865940ddf9c4"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_vlan_group_map_get" ref="a2943e03e105609c89d70865940ddf9c4" args="(const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_acl_vlan_group_t group_id, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used for getting the current mapping of vlans into vlan groups for ACL binding. the vlan_list parameter are arrays at the size of vlan_num which is filled by this function. the actual size is then returned as output.</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_list</td><td>- list of vlans which are members in this vlan group (in the given SWID) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vlan_num</td><td>- IN - number of elements allocated in the mapping entries arrays, OUT - number of actual elements found</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="a3f5727bed5f37c11a2691483d3f368c9"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_vlan_group_bind_set" ref="a3f5727bed5f37c11a2691483d3f368c9" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_vlan_group_t vlan_group, const sx_acl_id_t acl_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to bind/unbind ACL to vlan group. Binding more than one ACL to vlan group is allowed. Binding may fail if there is no place for the ACL in HW</p>
<p>When in 802.1D mode, instead of providing a Vlan group, you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- Vlan Group ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID of an ACL or ACL Group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd></dl>

</div>
</div>
<a class="anchor" id="ab91d548d2e1386edee4e5e4fd6c0813a"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_vlan_group_bind_get" ref="ab91d548d2e1386edee4e5e4fd6c0813a" args="(const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or ACL group which is bound to a specific vlan group</p>
<p>When in 802.1D mode, instead of providing a Vlan group, you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- Vlan Group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL Group</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if vlan group is not bound </dd></dl>

</div>
</div>
<a class="anchor" id="aaba4b8d2a4b0e13541c5d2dc33caead5"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_flex_key_attr_get" ref="aaba4b8d2a4b0e13541c5d2dc33caead5" args="(const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_flex_key_attr_t *key_attr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_attr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_flex_key_attr_t *&#160;</td>
          <td class="paramname"><em>key_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns attributes of the flexible key.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_handle</td><td>- The handle to flexible key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_width_p</td><td>- Key width</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND the key handle is wrong </dd></dl>

</div>
</div>
<a class="anchor" id="a77d6ceeb4c13e21075e9e25eb631976b"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_flex_key_set" ref="a77d6ceeb4c13e21075e9e25eb631976b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_t *key_list_p, const uint32_t key_count, sx_acl_key_type_t *key_handle_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_type_t *&#160;</td>
          <td class="paramname"><em>key_handle_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The key will be composed from predefined filter blocks of 9B keys by SCP algorithm and it maximum size is bounded to 54B. Key creation is pure DB operation. The maximum number of keys is equal to the maximum number of regions.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The access cmd CREATE/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_list_p</td><td>- Array of basic key ID's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_cnt</td><td>- Number of elements in basic key array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_handle_p</td><td>- The handle to created flexible key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED the wanted key cannot be created </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="af92b255d5ce7a24c8527cd55f61d8da1"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_flex_key_get" ref="af92b255d5ce7a24c8527cd55f61d8da1" args="(const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_key_t *key_list_p, uint32_t *key_count_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_count_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns list of filters included in the flexible key. The user is responsible for a memory management of the filters list.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_handle</td><td>- The handle to flexible key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_list_p</td><td>- Array of basic key ID's </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_count_p</td><td>- Number of elements in basic key array on return will contain the actual number of elements copied to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND the key handle is wrong </dd></dl>

</div>
</div>
<a class="anchor" id="acbf34d5037f1494d0c146ada9f407840"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_flex_rules_set" ref="acbf34d5037f1494d0c146ada9f407840" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, const sx_flex_acl_flex_rule_t *rules_list_p, const uint32_t rules_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_offset_t *&#160;</td>
          <td class="paramname"><em>offsets_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flex_acl_flex_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rules_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ACL rule is added or removed from a certain ACL region. The user is responsible for memory management - it is necessary to initialize each member of rules_list_p using call to sx_lib_flex_acl_rule_init before calling this API and de-initialize using call to sx_lib_flex_acl_rule_deinit after calling this API. This operation configures HW if the ACL is bound to a device. The configured rule is overrides the given offset with the new rule. The flexible ACL allows to the user to define set of filters that are subset of the key assigned to the region. Also the user can define a custom set of actions for each rule. The function should be called after bind ACL to region. If an offset in offsets array crosses the boundaries of the region allocation the function will fail.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The access command SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID received on a region creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets_list_p</td><td>- array of rule offset into region directly associated with the appropriate item on in array of rules </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_list_p</td><td>- Array of structures describing the flexible rule content (see the next table) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_cnt</td><td>- Number of elements in array of flexible rule descriptors</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED The sent command is unsupported </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND Wrong region ID </dd>
<dd>
SX_STATUS_NO_RESOURCES No more space for rules. Cannot allocate space for all actions </dd></dl>

</div>
</div>
<a class="anchor" id="a7820db61cf02508199106ad6b52562af"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_flex_rules_get" ref="a7820db61cf02508199106ad6b52562af" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, sx_flex_acl_flex_rule_t *rules_list_p, uint32_t *rules_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_offset_t *&#160;</td>
          <td class="paramname"><em>offsets_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flex_acl_flex_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rules_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns list of rules associated with particular region. The user is responsible for memory management - it is necessary to initialize each member of rules_list_p using call to sx_lib_flex_acl_rule_init before calling this API and de-initialize using call to sx_lib_flex_acl_rule_deinit after calling this API.</p>
<p>If the function is called with rules_list_p parameter set to NULL or *rules_cnt_p set to 0, it will return the actual number of rules set to the region.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to NULL and offset_list_p array filled with zeroes - it will return the actual number of keys and actions for each valid rule starting from offset 0, as well as the rule's offset in offset list for this rule.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to NULL, but offset_list_p array is filled with non-zero values - it will return the actual number of keys and actions for each valid rule according to the offset, which is defined in the offset list. In this case the offset list should be filled with offsets of the rules, which are valid.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to non-NULL, it is assumed that rule structures are allocated for all rules in the list. It also assumed that the offset list is filled with real offsets of the rules in the same order as in the rules list.</p>
<p>On Api call the key_desc_count and action_count of each sx_flex_acl_flex_rule_t should contain number of allocated items, on API return these parameters will contain actual number of items. The offset list should contain offsets of valid rules only.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID received on a region creation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets_list_p</td><td>- array of rule offset into region directly associated with the appropriate item on in array of rules </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rules_list_p</td><td>- Array of structures describing the flexible rule content (see the next table) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rules_cnt</td><td>- Desirable number of elements in array of flexible rule descriptors. Function return</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND Wrong region ID </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="a5affcc85683c3ceca56d5b2bfdc81a95"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rif_bind_set" ref="a5affcc85683c3ceca56d5b2bfdc81a95" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_rif_id_t rif_id, const sx_acl_id_t acl_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rif_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_id_t&#160;</td>
          <td class="paramname"><em>rif_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to bind/unbind ACL or ACL group to RIF</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The command BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_id</td><td>- RIF ID to bind/unbind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL or ACL group ID that is going to be bound to RIF</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID or RIF ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED the given comand is unsupported </dd>
<dd>
SX_STATUS_ERROR The operation cannot be complited </dd></dl>

</div>
</div>
<a class="anchor" id="a82890bcca35387bcad58a4cc8be18c4d"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_rif_bind_get" ref="a82890bcca35387bcad58a4cc8be18c4d" args="(const sx_api_handle_t handle, const sx_rif_id_t rif_id, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rif_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_id_t&#160;</td>
          <td class="paramname"><em>rif_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL or ACL group ID that bound to RIF</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_id</td><td>- RIF ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- The direction of ACL(ingress/egress) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL or ACL group ID that is bound to RIF</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID or RIF ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="a8d75e017d9af517108026cd99b68ece9"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_group_bind_set" ref="a8d75e017d9af517108026cd99b68ece9" args="(sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_id_t group_id, sx_acl_id_t next_group_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_bind_set </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>next_group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On ACL module initialization the user can choose the parallel ACL search type. This function is used to support this feature. It links one ACL group to another. Their relation could be described as "one directional linked list" where the second group is next to the first one. Only the head of the list of groups is allowed to be bound to port/VLAN/RIF. The other linked groups will be bound automatically. An attempt to bind explicitly the other but the head will cause to an error.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The command BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_group_id</td><td>- The first, parent ACL or ACL group ID that second one will be bound to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- The second ACL or ACL group ID that will be bound to the first one</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="aece9f1a820e5fe724e91b5ae46eac747"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_group_bind_get" ref="aece9f1a820e5fe724e91b5ae46eac747" args="(sx_api_handle_t handle, sx_acl_id_t group_id, sx_acl_id_t *group_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_bind_get </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the next ACL group bound to the given one.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- The first, parent ACL or ACL group ID that second one will be bound to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">group_id_p</td><td>- The ACL or ACL group ID that bound to the parent. In case of no one is bound to the parent invalid ACL ID will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="ab8f2477244a41031b345572131287a04"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_port_list_set" ref="ab8f2477244a41031b345572131287a04" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_port_list_entry_t *port_list_p, const uint32_t port_list_cnt, sx_acl_port_list_id_t *port_list_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_list_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_entry_t *&#160;</td>
          <td class="paramname"><em>port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_list_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_id_t *&#160;</td>
          <td class="paramname"><em>port_list_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manipulate a port list container Command CREATE creates a new container with the specified list of logical ports and returns its new container ID in port_list_id_p. Command SET replaces the contents of an existing container specified by port_list_id_p, with the specified list of logical ports in port_list_p. Command DESTROY deletes an existing container specified by port_list_id_p. Notes: An port list in use (e.g. by an acl key) cannot be destroyed or modified A container may contain at most RM_API_ACL_PORT_LIST_MAX logical ports A container may contain only Ethernet logical ports and not LAG ports</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/SET/DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_p</td><td>- Specifies or returns the container ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_cnt</td><td>- Specifies the list of logical ports for the container </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>port_list_id_p - specifies the id of the port list created/to change</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container ID does not exist. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if group is in use and cannot be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f73a62d89a23869e37faf3fa8933a60"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_port_list_get" ref="a1f73a62d89a23869e37faf3fa8933a60" args="(const sx_api_handle_t handle, const sx_acl_port_list_id_t port_list_id, sx_acl_port_list_entry_t *port_list_p, uint32_t *port_list_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_list_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_list_id_t&#160;</td>
          <td class="paramname"><em>port_list_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_entry_t *&#160;</td>
          <td class="paramname"><em>port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_list_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve information about a port list container specified by port_list_id. Notes: *port_list_cnt should contain the maximum amount of logical ports to retrieve. If port_list_p is NULL, then port_list_p are not retrieved at all. In this case port_list_cnt will contain the actual number if ports in the port list</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_id</td><td>- specifies the id of the port list to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_list_p</td><td>- array of ports to copy into </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_list_cnt_p</td><td>- Specifies the maximum amount of logical ports to retrieve, and returns the amount logical ports retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container does not exist, or no more containers. </dd></dl>

</div>
</div>
<a class="anchor" id="ab93629cae18b47ab7681567547431c5c"></a><!-- doxytag: member="sx_api_acl.h::sx_api_acl_region_hw_size_get" ref="ab93629cae18b47ab7681567547431c5c" args="(const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_size_t *region_size_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_hw_size_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_size_t *&#160;</td>
          <td class="paramname"><em>region_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to get ACL region HW size . Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">region_size_p</td><td>- The region actual hw size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Wed Sep 28 2016 16:16:00 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
