<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_vlan.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.4000</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_vlan.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__vlan_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a2c3502f091ada2dbc1b0310ea2fcf8c7">sx_api_vlan_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#ae8479b96c4320c716f3143e7fe104c7f">sx_api_vlan_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#afb0d34de6a2a947270fa84d2b5aba2db">sx_api_vlan_ports_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_vlan_ports_t *vlan_port_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#ac80375d25edca8f22d5398942027bfdd">sx_api_vlan_ports_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_vlan_ports_t *vlan_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a2b0abbd0b661c8f27750e6fd8aa9f896">sx_api_vlan_port_multi_vlan_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_vlans_t *vlan_list_p, const uint32_t vlan_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#aaf6c424bb2ab2ec004286887328394fa">sx_api_vlan_port_prio_tagged_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_untagged_prio_state_t untagged_prio_state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a38e5a89d75271e40606a5abd29c5199a">sx_api_vlan_port_prio_tagged_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_untagged_prio_state_t *untagged_prio_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a696226f61911e943a02e46fb04ea3d93">sx_api_vlan_port_ingr_filter_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_ingr_filter_mode_t ingress_filter_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a6cdd673321308c7fa7d37532eedc0d73">sx_api_vlan_port_ingr_filter_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_ingr_filter_mode_t *ingress_filter_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#aee3d030b4b7f32417ff503364c3d2978">sx_api_vlan_port_pvid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_vid_t pvid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a751922d4967927204d7d439d9097d1b2">sx_api_vlan_port_pvid_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vid_t *pvid_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a1f25355b4418d02ea8570e0c675d4976">sx_api_vlan_port_accptd_frm_types_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_vlan_frame_types_t *accptd_frm_types_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#acce5200b9809b58043dfd7e47d3f550f">sx_api_vlan_port_accptd_frm_types_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vlan_frame_types_t *accptd_frm_types_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a69b63f65e0cdb3c7cc3d6921b0c01bfa">sx_api_vlan_default_vid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a3b16a0fc55a249452147e121b71637a9">sx_api_vlan_default_vid_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_vid_t *vid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#ac8be9d5bbe7ac966b7f8a8e072e8f772">sx_api_vlan_unreg_mc_flood_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_vlan_unreg_flood_mode_t urmc_flood_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a4c541364d2855ebc0137407482a1ac4b">sx_api_vlan_unreg_mc_flood_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_vlan_unreg_flood_mode_t *urmc_flood_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a182cb39a575b35bd7278e1e780d65b2b">sx_api_vlan_unreg_mc_flood_ports_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a45814fe64c4958fad665b4eea4433cd3">sx_api_vlan_unreg_mc_flood_ports_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#ab857d0b13c92a60d5fda70968dea10a2">sx_api_vlan_port_qinq_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_qinq_mode_t qinq_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#aa9ec694a73851f1b7e480e649889a26b">sx_api_vlan_port_qinq_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_qinq_mode_t *qinq_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#abcf72663a766f5e766964fd9a58c07e2">sx_api_vlan_port_qinq_outer_prio_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_qinq_outer_prio_mode_t prio_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a5fd81c9708a52702cd91fcd0c5028882">sx_api_vlan_port_qinq_outer_prio_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_qinq_outer_prio_mode_t *prio_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#afd40bd8590718aaff2bc26ecf3ca7c39">sx_api_vlan_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__vlan_8h.html#a9591aec19debcc79f27fb8c3de09479c">sx_api_vlan_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2c3502f091ada2dbc1b0310ea2fcf8c7"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_log_verbosity_level_set" ref="a2c3502f091ada2dbc1b0310ea2fcf8c7" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the log verbosity level of VLAN MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- VLAN module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- VLAN API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="ae8479b96c4320c716f3143e7fe104c7f"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_log_verbosity_level_get" ref="ae8479b96c4320c716f3143e7fe104c7f" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the log verbosity level of VLAN MODULE Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- VLAN module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- VLAN API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully SX_STATUS_PARAM_ERROR if any input parameters is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="afb0d34de6a2a947270fa84d2b5aba2db"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_ports_set" ref="afb0d34de6a2a947270fa84d2b5aba2db" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_vlan_ports_t *vlan_port_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_ports_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_ports_t *&#160;</td>
          <td class="paramname"><em>vlan_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the VLAN member ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_port_list_p</td><td>- a pointer to array of port list structure. Each port in the list has its logical port number and the egress filter mode (tagged/ untagged and priority tagged member). If DELETE_ALL command is used port_cnt = 0, vlan_port_list_p = NULL are applicable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- number of ports in a port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_NO_RESOURCES if the pool cannot provide object </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ac80375d25edca8f22d5398942027bfdd"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_ports_get" ref="ac80375d25edca8f22d5398942027bfdd" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_vlan_ports_t *vlan_port_list_p, uint32_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_ports_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_ports_t *&#160;</td>
          <td class="paramname"><em>vlan_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the VLAN member ports. NOTE: If port_cnt_p is set as less than actual number of ports, the first port_cnt_p elements in array, and successful result are returned as output.</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vlan_port_list_p</td><td>- a pointer to array of VLAN port list structure. If it is NULL, the port_cnt_p variable is filled out with numbers of ports that could be retrieved. If the pointer is valid, VLAN ports are placed there and port_cnt_p takes actual number ports in array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- number of ports in a list that you want to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="a2b0abbd0b661c8f27750e6fd8aa9f896"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_multi_vlan_set" ref="a2b0abbd0b661c8f27750e6fd8aa9f896" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_port_vlans_t *vlan_list_p, const uint32_t vlan_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_multi_vlan_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_vlans_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vlan_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the VLANs list to a port in a single command. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_ADD - add list of VLANs to port SX_ACCESS_CMD_DELETE - remove a list VLANs from port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_list_p</td><td>- pointer to a VLANs list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_cnt</td><td>- size of VLANs list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_NO_RESOURCES if the pool cannot provide object </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aaf6c424bb2ab2ec004286887328394fa"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_prio_tagged_set" ref="aaf6c424bb2ab2ec004286887328394fa" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_untagged_prio_state_t untagged_prio_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_prio_tagged_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_untagged_prio_state_t&#160;</td>
          <td class="paramname"><em>untagged_prio_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the priority tagged attribute per port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">untagged_prio_state</td><td>- untagged packets are sent priority-tagged or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_NO_RESOURCES if the pool cannot provide object </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a38e5a89d75271e40606a5abd29c5199a"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_prio_tagged_get" ref="a38e5a89d75271e40606a5abd29c5199a" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_untagged_prio_state_t *untagged_prio_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_prio_tagged_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_untagged_prio_state_t *&#160;</td>
          <td class="paramname"><em>untagged_prio_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the priority tagged attribute per port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">untagged_prio_state_p</td><td>- untagged packets are sent priority-tagged or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a696226f61911e943a02e46fb04ea3d93"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_ingr_filter_set" ref="a696226f61911e943a02e46fb04ea3d93" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_ingr_filter_mode_t ingress_filter_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_ingr_filter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ingr_filter_mode_t&#160;</td>
          <td class="paramname"><em>ingress_filter_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API enables/disables ingress VLAN filtering on a port The VLAN membership is defined in sx_vlan_ports_set API. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ingress_filter_mode</td><td>- port ingress VLAN filter mode (enable/disable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported access command is requested </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a6cdd673321308c7fa7d37532eedc0d73"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_ingr_filter_get" ref="a6cdd673321308c7fa7d37532eedc0d73" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_ingr_filter_mode_t *ingress_filter_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_ingr_filter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ingr_filter_mode_t *&#160;</td>
          <td class="paramname"><em>ingress_filter_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves ingress VLAN filtering on a port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ingress_filter_state_p</td><td>- a pointer to port ingress VLAN filter state (enable/disable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="aee3d030b4b7f32417ff503364c3d2978"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_pvid_set" ref="aee3d030b4b7f32417ff503364c3d2978" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_vid_t pvid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_pvid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>pvid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets port's default VLAN ID. The PVID is set to untagged packets that ingress on the port. Note: When the PVID is deleted from the port, it is assigned with the default VLAN ID.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvid</td><td>- port VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a751922d4967927204d7d439d9097d1b2"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_pvid_get" ref="a751922d4967927204d7d439d9097d1b2" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vid_t *pvid_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_pvid_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vid_t *&#160;</td>
          <td class="paramname"><em>pvid_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves port's default VLAN ID. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvid_p</td><td>- Port VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a1f25355b4418d02ea8570e0c675d4976"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_accptd_frm_types_set" ref="a1f25355b4418d02ea8570e0c675d4976" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_vlan_frame_types_t *accptd_frm_types_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_accptd_frm_types_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_frame_types_t *&#160;</td>
          <td class="paramname"><em>accptd_frm_types_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets a port's accepted frame types. Note: By default, all ports are configured to accept all frame types Note: Priority tagged packets are considered as untagged packets</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accptd_frm_types_p</td><td>- struct holding the following values: allow_tagged, allow_untagged, allow_prio_tagged</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="acce5200b9809b58043dfd7e47d3f550f"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_accptd_frm_types_get" ref="acce5200b9809b58043dfd7e47d3f550f" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_vlan_frame_types_t *accptd_frm_types_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_accptd_frm_types_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_frame_types_t *&#160;</td>
          <td class="paramname"><em>accptd_frm_types_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves a port's accepted frame types. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">accptd_frm_types_p</td><td>- a pointer to struct holding the following values: allow_tagged, allow_untagged, allow_prio_tagged</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a69b63f65e0cdb3c7cc3d6921b0c01bfa"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_default_vid_set" ref="a69b63f65e0cdb3c7cc3d6921b0c01bfa" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_default_vid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the virtual switch's default VLAN ID. This VID is set by default as the PVID of all switch ports. If not called, the default VID for all virtual switches is 1.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- switch default VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ACCESS_CMD_UNSUPPORTED if unsupported access command is requested </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3b16a0fc55a249452147e121b71637a9"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_default_vid_get" ref="a3b16a0fc55a249452147e121b71637a9" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_vid_t *vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_default_vid_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vid_t *&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the virtual switch's default VLAN ID. This VID is set by default as the PVID of all switch ports. If not called, the default VID for all virtual switches is 1.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vid</td><td>- switch default VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ACCESS_CMD_UNSUPPORTED if unsupported access command is requested </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_MEMORY if problems with memory allocation occur </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8be9d5bbe7ac966b7f8a8e072e8f772"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_unreg_mc_flood_mode_set" ref="ac8be9d5bbe7ac966b7f8a8e072e8f772" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_vlan_unreg_flood_mode_t urmc_flood_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_unreg_mc_flood_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_unreg_flood_mode_t&#160;</td>
          <td class="paramname"><em>urmc_flood_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets unregistered MC flood mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urmc_flood_mode</td><td>- unregistered MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a4c541364d2855ebc0137407482a1ac4b"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_unreg_mc_flood_mode_get" ref="a4c541364d2855ebc0137407482a1ac4b" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_vlan_unreg_flood_mode_t *urmc_flood_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_unreg_mc_flood_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_unreg_flood_mode_t *&#160;</td>
          <td class="paramname"><em>urmc_flood_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves unregistered MC flood mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">urmc_flood_mode_p</td><td>- unregister MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a182cb39a575b35bd7278e1e780d65b2b"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_unreg_mc_flood_ports_set" ref="a182cb39a575b35bd7278e1e780d65b2b" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_unreg_mc_flood_ports_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets unregistered MC flood ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port may be a LAG or physical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a45814fe64c4958fad665b4eea4433cd3"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_unreg_mc_flood_ports_get" ref="a45814fe64c4958fad665b4eea4433cd3" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_unreg_mc_flood_ports_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves unregistered MC flood ports. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port can be LAG or physical port </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ab857d0b13c92a60d5fda70968dea10a2"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_qinq_mode_set" ref="ab857d0b13c92a60d5fda70968dea10a2" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_qinq_mode_t qinq_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_qinq_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_qinq_mode_t&#160;</td>
          <td class="paramname"><em>qinq_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets Q-in-Q mode of port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qinq_mode</td><td>- mode: Q-in-Q enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="aa9ec694a73851f1b7e480e649889a26b"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_qinq_mode_get" ref="aa9ec694a73851f1b7e480e649889a26b" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_qinq_mode_t *qinq_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_qinq_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_qinq_mode_t *&#160;</td>
          <td class="paramname"><em>qinq_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves Q-in-Q mode of port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qinq_mode_p</td><td>- the retrieved mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="abcf72663a766f5e766964fd9a58c07e2"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_qinq_outer_prio_mode_set" ref="abcf72663a766f5e766964fd9a58c07e2" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_qinq_outer_prio_mode_t prio_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_qinq_outer_prio_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_qinq_outer_prio_mode_t&#160;</td>
          <td class="paramname"><em>prio_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The API sets which priority should be taken for the outer tag (when Q-in-Q is enabled): The port's default priority, or the inner tag's priority.</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_mode</td><td>- mode: default/inner priority</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameters exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if a requested element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a5fd81c9708a52702cd91fcd0c5028882"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_port_qinq_outer_prio_mode_get" ref="a5fd81c9708a52702cd91fcd0c5028882" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_qinq_outer_prio_mode_t *prio_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_port_qinq_outer_prio_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_qinq_outer_prio_mode_t *&#160;</td>
          <td class="paramname"><em>prio_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves port's Q-in-Q outer tag priority mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prio_mode_p</td><td>- the retrieved mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle is invalid </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="afd40bd8590718aaff2bc26ecf3ca7c39"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_set" ref="afd40bd8590718aaff2bc26ecf3ca7c39" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API creates .1Q vlans. If NO_RESOURCES status is returned then the vlan_list_p will contain the vlans which were not added (number of which is donated by vlan_cnt_p). Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_list_p</td><td>- A list of .1Q vlans to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_cnt_p</td><td>- The size of vlan_list_p array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_NO_RESOURCES if all the .1Q vlans have been set. </dd>
<dd>
SX_STATUS_PARAM_ERROR if vlan_list_p is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a9591aec19debcc79f27fb8c3de09479c"></a><!-- doxytag: member="sx_api_vlan.h::sx_api_vlan_get" ref="a9591aec19debcc79f27fb8c3de09479c" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_vlan_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API returns the list of .1Q vlans added to the swid. Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch partition ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_list_p</td><td>- A list of .1Q vlans to add. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vlan_cnt_p</td><td>- The number of vlans to return. If vlan_cnt_p==0, Only the number of vlans will be returned and the list will remain empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if vlan_list_p is NULL. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Wed Feb 1 2017 20:15:02 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
