<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_fdb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.2002</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_fdb.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__fdb_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa402a02c1b476045b0bdbfaf4d9e466f">sx_api_fdb_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af69328504a7116dc2db6b42b18b13b16">sx_api_fdb_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#acac719da53d4e58dc48ffc21dfce3460">sx_api_fdb_age_time_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a4396ebb8d79d5757b3f2df8b4ff3dd51">sx_api_fdb_age_time_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0c85bf694d723fc41318b9f41f801e8a">sx_api_fdb_poll_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0fc878a321456849b437245a3889fa2d">sx_api_fdb_polling_interval_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a53cad0c84e98f74c17ff84e111689b3b">sx_api_fdb_polling_interval_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_polling_interval_t *interval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a463c7cb7c07a29ccba6f1bd5c56fc723">sx_api_fdb_uc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab9d08fd9a8c2e68d0857b5ae986b5cf5">sx_api_fdb_uc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa216c40f7212a34ff4f48cdd514b7142">sx_api_fdb_uc_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *data_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ac844669ce5b39ebd0c54403b2ef31207">sx_api_fdb_uc_port_count_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3c5e069db7cd02240336f1ddd556e507">sx_api_fdb_uc_fid_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7780abaea19956b6bd7a6738e81e5867">sx_api_fdb_uc_limit_port_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8649abe905403e7facd2edcad0f896a1">sx_api_fdb_uc_limit_port_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8e82f33acfac26987e66dd53dee91c38">sx_api_fdb_uc_limit_fid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const uint32_t limit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a760a24322ae990cad9789b7a579053db">sx_api_fdb_uc_limit_fid_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *limit_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab5444b9e90b307936d49fe0c70232cc9">sx_api_fdb_mc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3640c0c7f4b5fb0112a6342872835131">sx_api_fdb_mc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a9efbb7fc69d64edd9762d6e47dc99bd3">sx_api_fdb_mc_mac_addr_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_mac_addr_t group_addr, const sx_mc_container_id_t destinantion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a297760be979e3e1c5efb6107b2bdf897">sx_api_fdb_mc_mac_addr_group_get</a> (const sx_api_handle_t handle, const sx_fid_t fid, const sx_mac_addr_t group_addr, sx_mc_container_id_t *destinantion_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af975d298e288b3700edb6bfa46ffe9e6">sx_api_fdb_uc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a607d3e59f86ea3030361a4d3ab11ca77">sx_api_fdb_uc_flush_port_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af9bda072a8e6c293b7ee18e106a0818f">sx_api_fdb_uc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa694899ca36680e9e2fb2205831ed0fd">sx_api_fdb_uc_flush_port_fid_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fid_t fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a6731a3466288aedc59c1235f43c6820a">sx_api_fdb_mc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a39c1584e35170d3ed04ef20904a57f6c">sx_api_fdb_mc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad302ac34a0c93901a8d71c84b830d55e">sx_api_fdb_fid_vlan_member_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3021865defc7ae5cb76077cb049f910d">sx_api_fdb_global_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_ctrl_t learn_ctrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af2fc5b5032c1b055937b1b04f66def7c">sx_api_fdb_global_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_ctrl_t *learn_ctrl_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af6adc069af59af3c899204cd18445b3f">sx_api_fdb_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a9b53851631fac831d1933522be461403">sx_api_fdb_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad8e05ca88a0204e228589ca94d28af1c">sx_api_fdb_fid_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1228d15d780af59066b92bf2efd7d352">sx_api_fdb_fid_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a635769f9f07a0d564566ca33ebd44884">sx_api_fdb_port_learn_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa5156883cfdbcb9f246df889d0199eb7">sx_api_fdb_port_learn_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a51dd7cd5a11e51b9be1f25e62fd40a">sx_api_fdb_notify_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab2b8c246f21456f227318b5626ca7740">sx_api_fdb_notify_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a65caac4b1e478dbce337541fdfc046f2">sx_api_fdb_flood_control_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, const uint16_t ports_count, const sx_port_log_id_t *const ports_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a311aebd885a87ff66de06c452130dd">sx_api_fdb_flood_control_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, uint16_t *const ports_count, sx_port_log_id_t *const ports_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8da695d5cace309ac0e60610813439eb">sx_api_fdb_flood_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_mc_container_id_t flood_vector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1e981ca9364245537dc47b36eaf1ad91">sx_api_fdb_flood_get</a> (const sx_api_handle_t handle, const sx_fid_t fid, sx_mc_container_id_t *flood_vector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a2e4a16b9c750215270a1ffceb7d6e150">sx_api_fdb_flood_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_flood_counters_t *const counters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a61db615ac875ccce214e8600b86102c8">sx_api_fdb_flood_counter_clear</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0ea4fb90301561b60d52be1e6d3d8199">sx_api_fdb_src_miss_protect_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t enable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af051ad00c09fa031624b47294adad966">sx_api_fdb_src_miss_protect_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, boolean_t *enable_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aca4e77d99c8a0a02143ab1b20d5a3fd3">sx_api_fdb_src_miss_protect_drop_cntr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#acd8c7fe52e1a7a66bb116406820919e3">sx_api_fdb_src_miss_protect_drop_cntr_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, uint64_t *dropped_pkts_cntr)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa402a02c1b476045b0bdbfaf4d9e466f"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_log_verbosity_level_set" ref="aa402a02c1b476045b0bdbfaf4d9e466f" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the log verbosity level of FDB MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="af69328504a7116dc2db6b42b18b13b16"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_log_verbosity_level_get" ref="af69328504a7116dc2db6b42b18b13b16" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the log verbosity level of FDB MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="acac719da53d4e58dc48ffc21dfce3460"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_age_time_set" ref="acac719da53d4e58dc48ffc21dfce3460" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_age_time_t&#160;</td>
          <td class="paramname"><em>age_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">age_time</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a4396ebb8d79d5757b3f2df8b4ff3dd51"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_age_time_get" ref="a4396ebb8d79d5757b3f2df8b4ff3dd51" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_age_time_t *&#160;</td>
          <td class="paramname"><em>age_time_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">age_time_p</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a0c85bf694d723fc41318b9f41f801e8a"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_poll_set" ref="a0c85bf694d723fc41318b9f41f801e8a" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_poll_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the FDB poll for MAC entries notifications. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no place in the jobs buffer </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a0fc878a321456849b437245a3889fa2d"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_polling_interval_set" ref="a0fc878a321456849b437245a3889fa2d" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_polling_interval_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the FDB polling interval from HW in 0.1 seconds. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a53cad0c84e98f74c17ff84e111689b3b"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_polling_interval_get" ref="a53cad0c84e98f74c17ff84e111689b3b" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_polling_interval_t *interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_polling_interval_t *&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the FDB polling interval in 0.1 seconds seconds. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a463c7cb7c07a29ccba6f1bd5c56fc723"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_mac_addr_set" ref="a463c7cb7c07a29ccba6f1bd5c56fc723" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes UC MAC and UC LAG MAC entries to/from the FDB. In case the operation fails on one entry (or more), an error is returned, mac_list_p stores those entries, and their quantity is stored in data_cnt. If the operation is completed successfully, SUCCESS is returned, and data_cnt_p and mac_list_p are not changed. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) or fid (filtering ID) in mac_list_p-&gt;fid_vid, you should provide a bridge_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_list_p</td><td>- list of MAC record parameters. Upon deletion, entry_type is DONT_CARE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of MAC records to ADD/DELETE</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if the FDB hash bin is full </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d08fd9a8c2e68d0857b5ae986b5cf5"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_mac_addr_get" ref="ab9d08fd9a8c2e68d0857b5ae986b5cf5" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_entry_type_t&#160;</td>
          <td class="paramname"><em>mac_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_key_filter_t *&#160;</td>
          <td class="paramname"><em>key_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads MAC entries from the SW FDB table, which is an exact copy of the HW DB on any device. The output supports up to SX_FDB_MAX_GET_ENTRIES entries whose default is 64.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) get information for current MAC + vlan - you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to 1. cmd should be SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>2) get a list of first n&lt;=64 MACs - data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GET_FIRST.</li>
</ul>
<ul>
<li>3) get a list of n&lt;=64 MACs which comes after certain MAC record (it does not have to exist) you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<p>mac_list_p returns the records info and their quantity in data_cnt_p for all types of requests.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) or fid (filtering ID) in key_p-&gt;fid_vid and fid in key_filter_p-&gt;fid, you should provide a bridge_id. bridge_id's will be stored in mac_list_p-&gt;fid_vid Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- get, get_next, get first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_type</td><td>- static, dynamic, all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- MAC entry with information for search (MAC+FID) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_filter_p</td><td>- filter types used on the mac_list_p - FID/MAC/logical port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_list_p</td><td>- pointer to list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of entries to retrieve, also retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aa216c40f7212a34ff4f48cdd514b7142"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_count_get" ref="aa216c40f7212a34ff4f48cdd514b7142" args="(const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function counts all MAC entries in the SW FDB table (static and dynamic). Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ac844669ce5b39ebd0c54403b2ef31207"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_port_count_get" ref="ac844669ce5b39ebd0c54403b2ef31207" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_port_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the amount of MACs learned on a port (static and dynamic). Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5e069db7cd02240336f1ddd556e507"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_fid_count_get" ref="a3c5e069db7cd02240336f1ddd556e507" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_fid_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the amount of MACs learned on an FID (static and dynamic).</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a7780abaea19956b6bd7a6738e81e5867"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_port_set" ref="a7780abaea19956b6bd7a6738e81e5867" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on a port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a8649abe905403e7facd2edcad0f896a1"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_port_get" ref="a8649abe905403e7facd2edcad0f896a1" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on a port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a8e82f33acfac26987e66dd53dee91c38"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_fid_set" ref="a8e82f33acfac26987e66dd53dee91c38" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const uint32_t limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID/FID/limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a760a24322ae990cad9789b7a579053db"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_limit_fid_get" ref="a760a24322ae990cad9789b7a579053db" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *limit_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on an FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ab5444b9e90b307936d49fe0c70232cc9"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_set" ref="ab5444b9e90b307936d49fe0c70232cc9" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes MC MAC entries from the FDB. Note: MC entries cannot be created and associated with ports at the same time.</p>
<p>Note: The log_port_list_p list should not contain the logical port items which are specified as an Ethernet port and which are members of a LAG port at same time.</p>
<p>When the ADD command is requested this function performs the following:</p>
<ul>
<li>checks a MC group is already created and returns FAILURE if yes;</li>
<li>allocates and stores the MC group;</li>
</ul>
<p>When the DELETE command is requested this function performs the following for each leaf device:</p>
<ul>
<li>deletes MC FDB records</li>
<li>deletes FDB MC ID records</li>
<li>deletes SPGT record</li>
<li>deletes MC group from MCDB</li>
<li>returns pgi into the pool</li>
</ul>
<p>When Edit (add_port) command is requested this function performs the following:</p>
<ul>
<li>updates the MC DB for adding logical ports and LAG ports</li>
<li>for each leaf device:<ul>
<li>retrieves a list of LAG-member logical ports from LAGLib for all LAG logical ports which belong to this MC group</li>
<li>updates the SPGT record for adding the spine, MC members and LAGs member ports</li>
<li>adds local ports to FDB MC ID records (if FDB look-up by MC ID is allowed on leaf devices)</li>
</ul>
</li>
</ul>
<p>When Edit (delete_port) command is requested this function performs the following:</p>
<ul>
<li>updates MC DB for deleting logical ports and LAG ports</li>
<li>for each leaf device:<ul>
<li>updates the SPGT record for deleting requested ports (if logical port is a LAG port then all LAG-member logical ports are removed);</li>
<li>removes local ports from FDB MC ID records (if FDB look up by MC ID is allowed on leaf devices)</li>
</ul>
</li>
</ul>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete/add port/delete port/test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3640c0c7f4b5fb0112a6342872835131"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_get" ref="a3640c0c7f4b5fb0112a6342872835131" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves MC MAC entries data. NOTE: The log_port_list_p list contains LAG-port IDs only and does not contain LAG members' logical-port IDs.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a9efbb7fc69d64edd9762d6e47dc99bd3"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_group_set" ref="a9efbb7fc69d64edd9762d6e47dc99bd3" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_mac_addr_t group_addr, const sx_mc_container_id_t destinantion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sx_status_t sx_api_fdb_mc_mac_addr_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_container_id_t&#160;</td>
          <td class="paramname"><em>destinantion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes MC MAC entries from the FDB. using multicast container as destination.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>- a pointer to a mc container presenting the dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a297760be979e3e1c5efb6107b2bdf897"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_mac_addr_group_get" ref="a297760be979e3e1c5efb6107b2bdf897" args="(const sx_api_handle_t handle, const sx_fid_t fid, const sx_mac_addr_t group_addr, sx_mc_container_id_t *destinantion_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sx_status_t sx_api_fdb_mc_mac_addr_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_container_id_t *&#160;</td>
          <td class="paramname"><em>destinantion_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function get MC MAC entries from the FDB. using multicast container as destination.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destinantion_p</td><td>- a pointer to a mc container presenting the dest</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="af975d298e288b3700edb6bfa46ffe9e6"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_all_set" ref="af975d298e288b3700edb6bfa46ffe9e6" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes all FDB table entries on a switch partition. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a607d3e59f86ea3030361a4d3ab11ca77"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_port_set" ref="a607d3e59f86ea3030361a4d3ab11ca77" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes the FDB table entries that are related to a flushed port. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="af9bda072a8e6c293b7ee18e106a0818f"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_fid_set" ref="af9bda072a8e6c293b7ee18e106a0818f" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes all FDB table entries that were learned on the flushed FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aa694899ca36680e9e2fb2205831ed0fd"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_uc_flush_port_fid_set" ref="aa694899ca36680e9e2fb2205831ed0fd" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes all FDB table entries that were learned on the flushed FID and port.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a6731a3466288aedc59c1235f43c6820a"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_flush_all_set" ref="a6731a3466288aedc59c1235f43c6820a" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes all FDB MC tables on a switch partition. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a39c1584e35170d3ed04ef20904a57f6c"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_mc_flush_fid_set" ref="a39c1584e35170d3ed04ef20904a57f6c" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function deletes all FDB MC table entries that were learned on the flushed FID on a switch partition.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ad302ac34a0c93901a8d71c84b830d55e"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_vlan_member_set" ref="ad302ac34a0c93901a8d71c84b830d55e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_vlan_member_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function maps VLANs to filtering databases for shared VLAN learning (SVL) between VLANs. If independent VLAN learning is desired, a single VLAN should be mapped to a single FID.</p>
<p>When cmd=add This function adds FID to VID mapping record to the selected SWID. When cmd=delete This function deletes FID to VID mapping record from the selected SWID. The DEF_FID value is added to the corresponding VLAN.</p>
<p>NOTE: This API performs FDB flushing by FID before FID to VID mapping changing</p>
<p>NOTE: Only independent learning is supported in the current release.</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: SwitchX, SwitchX2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3021865defc7ae5cb76077cb049f910d"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_global_params_set" ref="a3021865defc7ae5cb76077cb049f910d" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_ctrl_t learn_ctrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_ctrl_t&#160;</td>
          <td class="paramname"><em>learn_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the SWID's learning parameters into the system's DB.</p>
<p>NOTE: Only independent learning is supported in the current release. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch (virtual) ID (whose parameters to set) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_ctrl</td><td>- is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="af2fc5b5032c1b055937b1b04f66def7c"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_global_params_get" ref="af2fc5b5032c1b055937b1b04f66def7c" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_ctrl_t *learn_ctrl_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_ctrl_t *&#160;</td>
          <td class="paramname"><em>learn_ctrl_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API retrieves the SWID's learning parameters from the system's DB. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch (virtual) ID (whose parameters to retrieve) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_ctrl_p</td><td>- Is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="af6adc069af59af3c899204cd18445b3f"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_learn_mode_set" ref="af6adc069af59af3c899204cd18445b3f" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the FDB learning mode per SWID affecting all ports and VLANs in the SWID. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- new SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a9b53851631fac831d1933522be461403"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_learn_mode_get" ref="a9b53851631fac831d1933522be461403" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the FDB learning mode per SWID. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e05ca88a0204e228589ca94d28af1c"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_learn_mode_set" ref="ad8e05ca88a0204e228589ca94d28af1c" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets FID's learn mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a1228d15d780af59066b92bf2efd7d352"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_fid_learn_mode_get" ref="a1228d15d780af59066b92bf2efd7d352" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets fid's learn mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a635769f9f07a0d564566ca33ebd44884"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_port_learn_mode_set" ref="a635769f9f07a0d564566ca33ebd44884" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets port's learn mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aa5156883cfdbcb9f246df889d0199eb7"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_port_learn_mode_get" ref="aa5156883cfdbcb9f246df889d0199eb7" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets port's learn mode. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a5a51dd7cd5a11e51b9be1f25e62fd40a"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_notify_params_set" ref="a5a51dd7cd5a11e51b9be1f25e62fd40a" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_notify_params_t *notify_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets FDB notify parameters. Note: Only takes effect when controlled learn mode is set. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_params_p</td><td>- new notify params</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b8c246f21456f227318b5626ca7740"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_notify_params_get" ref="ab2b8c246f21456f227318b5626ca7740" args="(const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_notify_params_t *notify_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets FDB notify parameters. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">notify_params_p</td><td>- swid's notify params</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a65caac4b1e478dbce337541fdfc046f2"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_control_set" ref="a65caac4b1e478dbce337541fdfc046f2" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, const uint16_t ports_count, const sx_port_log_id_t *const ports_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to block ports from flooding of selected FID. This function is not supported in SwitchX Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD_PORTS / DELETE_PORTS / DELETE_ALL_PORTS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_list</td><td>- Array of logical ports</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and cmd is not DELETE_ALL_PORTS </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED Command provided is not supported. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a5a311aebd885a87ff66de06c452130dd"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_control_get" ref="a5a311aebd885a87ff66de06c452130dd" args="(const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, uint16_t *const ports_count, sx_port_log_id_t *const ports_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to retrieve blocked ports from flooding of selected FID. ports count will be updated with the number of blocked ports. passing ports_count 0 and ports_list NULL, will return the number of ports in ports_count. This function is not supported in SwitchX Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array, returned as number of actual ports </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ports_list</td><td>- (Optional) Array to fill blocked logical ports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and ports_count is not 0. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a8da695d5cace309ac0e60610813439eb"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_set" ref="a8da695d5cace309ac0e60610813439eb" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_mc_container_id_t flood_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sx_status_t sx_api_fdb_flood_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_container_id_t&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to manage flood control for tunnels. for each tunnel, you can add or remove flooding for specificed bridges.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_vector</td><td>- MC Container contains Flooding vector as ecmp object for head replication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel or fid doesn't exists. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if fid already have flooding vector. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a1e981ca9364245537dc47b36eaf1ad91"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_get" ref="a1e981ca9364245537dc47b36eaf1ad91" args="(const sx_api_handle_t handle, const sx_fid_t fid, sx_mc_container_id_t *flood_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sx_status_t sx_api_fdb_flood_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_container_id_t *&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to get flood control settings for a tunnel Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flood_vector</td><td>- MC Container contains Flooding vector as ecmp object for head replication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if flooding vector not set </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4a16b9c750215270a1ffceb7d6e150"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_counter_get" ref="a2e4a16b9c750215270a1ffceb7d6e150" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_flood_counters_t *const counters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_counters_t *const&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to retrieve flooding counters of the switch This function is not supported in SwitchX Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>- counters struct to retrieve information to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command provided is not supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if counters is null </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a61db615ac875ccce214e8600b86102c8"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_flood_counter_clear" ref="a61db615ac875ccce214e8600b86102c8" args="(const sx_api_handle_t handle, const sx_swid_t swid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_clear </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to clear flooding counters of the switch This function is not supported in SwitchX Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea4fb90301561b60d52be1e6d3d8199"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_src_miss_protect_set" ref="a0ea4fb90301561b60d52be1e6d3d8199" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets port's fdb miss protect mode. Supported devices: SwitchX, SwitchX2, SwitchEN.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>- enable smac miss port protection</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="af051ad00c09fa031624b47294adad966"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_src_miss_protect_get" ref="af051ad00c09fa031624b47294adad966" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, boolean_t *enable_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>enable_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets port's fdb miss protect mode. Supported devices: SwitchX, SwitchX2, SwitchEN.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enable_p</td><td>- port's fdb miss protection enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="aca4e77d99c8a0a02143ab1b20d5a3fd3"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_src_miss_protect_drop_cntr_set" ref="aca4e77d99c8a0a02143ab1b20d5a3fd3" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets port's source miss protection drop counter. Supported devices: SwitchX, SwitchX2, SwitchEN.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="acd8c7fe52e1a7a66bb116406820919e3"></a><!-- doxytag: member="sx_api_fdb.h::sx_api_fdb_src_miss_protect_drop_cntr_get" ref="acd8c7fe52e1a7a66bb116406820919e3" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, uint64_t *dropped_pkts_cntr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dropped_pkts_cntr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets port's source miss protection drop counter. Supported devices: SwitchX, SwitchX2, SwitchEN.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET / GET_AND_CLEAR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dropped_pkts_cntr</td><td>- port's source miss protection</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Tue Jun 14 2016 21:18:10 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
